<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Autonomous Vehicle Simulator - Neural AI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f1c3f 0%, #1a2e5a 50%, #0f1c3f 100%);
            color: #003d7a;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .header {
            background: linear-gradient(to right, #0052b3 0%, #1e90ff 50%, #0052b3 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border-bottom: 3px solid #1e90ff;
        }

        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 1px;
        }

        .header p {
            margin: 5px 0 0 0;
            font-size: 12px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .container {
            display: flex;
            height: calc(100vh - 70px);
            gap: 12px;
            padding: 12px;
            background: transparent;
        }

        .canvas-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        canvas {
            background: linear-gradient(to bottom, #e0f2ff 0%, #f5faff 100%);
            border: 3px solid #0052b3;
            flex: 1;
            cursor: crosshair;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 82, 179, 0.15);
        }

        .controls {
            background: linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%);
            border: 2px solid #0052b3;
            padding: 12px;
            border-radius: 8px;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 82, 179, 0.15);
            transition: all 0.3s ease;
        }

        button {
            background: linear-gradient(to bottom, #0052b3 0%, #003d7a 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 8px rgba(0, 82, 179, 0.2);
        }

        button:hover {
            background: linear-gradient(to bottom, #1e90ff 0%, #0052b3 100%);
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(0, 82, 179, 0.4);
        }

        button:active {
            transform: translateY(-1px);
        }

        button.active {
            background: #1e90ff;
            box-shadow: 0 0 0 3px rgba(30, 144, 255, 0.2);
        }

        button.spawn-mode {
            background: #28a745;
        }

        button.spawn-mode:hover {
            background: #218838;
        }

        button.delete-mode {
            background: #dc3545;
        }

        button.delete-mode:hover {
            background: #c82333;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
            border-right: 2px solid #c2dff5;
            padding-right: 12px;
        }

        .control-group:last-child {
            border-right: none;
        }

        label {
            font-size: 13px;
            color: #003d7a;
            font-weight: 500;
        }

        .output-section {
            width: 360px;
            min-width: 360px;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 82, 179, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            max-height: calc(100vh - 90px);
        }

        .output-panel {
            background: linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%);
            border: 2px solid #0052b3;
            border-radius: 8px;
            padding: 10px;
            min-height: 180px;
            max-height: 280px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.5;
            box-shadow: 0 4px 15px rgba(0, 82, 179, 0.15);
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .output-panel h3 {
            color: #003d7a;
            border-bottom: 2px solid #0052b3;
            margin-bottom: 12px;
            padding-bottom: 8px;
            font-weight: 600;
        }

        .action-log {
            list-style: none;
            color: #003d7a;
        }

        .action-log li {
            margin: 3px 0;
            padding: 4px 6px;
            border-left: 2px solid #0052b3;
            padding-left: 8px;
            word-break: break-word;
            background: #f0f5fa;
            border-radius: 3px;
            font-size: 10px;
        }

        .action-log li.critical {
            color: #721c24;
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .action-log li.warning {
            color: #856404;
            border-left-color: #ffc107;
            background: #fff3cd;
        }

        .action-log li.info {
            color: #0c5460;
            border-left-color: #17a2b8;
            background: #d1ecf1;
        }

        .stats {
            background: linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%);
            border: 2px solid #0052b3;
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            box-shadow: 0 4px 15px rgba(0, 82, 179, 0.15);
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }

        .stats:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 82, 179, 0.2);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            padding: 3px 0;
            border-bottom: 1px solid #c2dff5;
            color: #003d7a;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .speed-indicator {
            width: 100%;
            height: 12px;
            background: #c2dff5;
            border: 1px solid #0052b3;
            border-radius: 6px;
            margin: 6px 0;
            overflow: hidden;
        }

        .speed-fill {
            height: 100%;
            background: linear-gradient(to right, #28a745, #ffc107, #dc3545);
            width: 0%;
            transition: width 0.3s;
            border-radius: 6px;
        }

        .traffic-light-control {
            background: linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%);
            border: 2px solid #0052b3;
            padding: 9px;
            border-radius: 8px;
            margin-top: 8px;
            box-shadow: 0 4px 15px rgba(0, 82, 179, 0.15);
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }

        .traffic-light-control:hover {
            transform: translateY(-2px);
        }

        .traffic-light-control h3 {
            color: #003d7a;
            font-size: 12px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .light-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .light-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            border: 2px solid #003d7a;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .light-btn.red {
            background: #dc3545;
        }

        .light-btn.yellow {
            background: #ffc107;
        }

        .light-btn.green {
            background: #28a745;
        }

        .light-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        ::-webkit-scrollbar-thumb {
            background: #0066cc;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #0052a3;
        }

        .title {
            color: #0052a3;
            text-align: center;
            margin-bottom: 8px;
            font-size: 15px;
            font-weight: 600;
        }

        .spawn-hint {
            background: #ffc107;
            color: #1a3a52;
            padding: 6px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
        }

        .crash-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 3px solid #dc3545;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(220, 53, 69, 0.3);
        }

        .crash-modal h2 {
            color: #dc3545;
            font-size: 32px;
            margin: 0 0 20px 0;
            text-shadow: none;
        }

        .crash-modal p {
            color: #1a3a52;
            font-size: 18px;
            margin: 0 0 30px 0;
        }

        .crash-modal button {
            background: #dc3545;
            color: #fff;
            border: none;
            padding: 15px 40px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s;
        }

        .crash-modal button:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }

        .crash-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }



        .ai-stats-advanced {
            background: linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%);
            border: 2px solid #0052b3;
            padding: 9px;
            border-radius: 8px;
            font-size: 10px;
            box-shadow: 0 4px 15px rgba(0, 82, 179, 0.15);
            margin-top: 8px;
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }

        .ai-stats-advanced:hover {
            transform: translateY(-2px);
        }

        .ai-stats-advanced h4 {
            color: #003d7a;
            font-size: 12px;
            margin-bottom: 8px;
            border-bottom: 1px solid #0052b3;
            padding-bottom: 5px;
        }

        .ai-metric {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            color: #1a3a52;
        }

        .ai-metric .label {
            font-weight: 600;
        }

        .ai-metric .value {
            color: #0052b3;
            font-weight: 700;
        }

        .threat-bar {
            width: 100%;
            height: 6px;
            background: #c2dff5;
            border-radius: 3px;
            margin: 4px 0;
            overflow: hidden;
            border: 1px solid #0052b3;
        }

        .threat-fill {
            height: 100%;
            background: linear-gradient(to right, #28a745, #ffc107, #dc3545);
            border-radius: 3px;
            transition: width 0.3s;
        }

        .prediction-panel {
            background: linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%);
            border: 2px solid #0052b3;
            border-radius: 8px;
            padding: 9px;
            margin-top: 8px;
            font-size: 10px;
            box-shadow: 0 4px 15px rgba(0, 82, 179, 0.15);
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }

        .prediction-panel:hover {
            transform: translateY(-2px);
        }

        .prediction-panel h4 {
            color: #003d7a;
            font-size: 12px;
            margin-bottom: 8px;
            border-bottom: 1px solid #0052b3;
            padding-bottom: 5px;
        }

        .prediction-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            color: #1a3a52;
            border-bottom: 1px solid #e6f2ff;
        }

        .prediction-item:last-child {
            border-bottom: none;
        }

        .confidence {
            color: #0052b3;
            font-weight: 600;
        }

        .mode-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            background: #0052b3;
        }

        .mode-indicator.aggressive {
            background: #dc3545;
        }

        .mode-indicator.cautious {
            background: #ffc107;
            color: #1a3a52;
        }

        .mode-indicator.normal {
            background: #28a745;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>ðŸš— AUTONOMOUS VEHICLE SIMULATOR</h1>
        <p>Advanced AI-Powered Navigation System with Real-Time Threat Detection</p>
    </div>

    <div class="container">
        <div class="canvas-section">
            <canvas id="canvas" width="50" height="0"></canvas>

            <div class="controls">
                <div class="control-group">
                    <label><i class="fas fa-car mr-2"></i>Vehicles:</label>
                    <button id="spawnCar"><i class="fas fa-car mr-2"></i>Car</button>
                    <button id="spawnBus" class=""><i class="fas fa-bus mr-2"></i>Bus</button>
                    <button id="spawnTruck"><i class="fas fa-truck mr-2"></i>Truck</button>
                    <button id="spawnTrafficJam"><i class="fas fa-traffic-light mr-2"></i>Jam</button>
                </div>

                <div class="control-group">
                    <label><i class="fas fa-person mr-2"></i>Pedestrians:</label>
                    <button id="spawnPerson" class=""><i class="fas fa-person mr-2"></i>Person</button>
                    <button id="spawnGroupPeople"><i class="fas fa-people-group mr-2"></i>Group</button>
                    <div id="personCustomizer" style="display: none; gap: 5px; align-items: center;">
                        <input type="text" id="personName" placeholder="Name" maxlength="15"
                            style="width: 80px; padding: 5px; border-radius: 4px; border: 1px solid #0066cc; background: white; color: #1a3a52;">
                        <input type="color" id="personColor" value="#ff99ff"
                            style="width: 40px; height: 30px; cursor: pointer; border: 1px solid #0066cc; border-radius: 4px;">
                    </div>
                </div>

                <div class="control-group">
                    <label><i class="fas fa-sign mr-2"></i>Traffic Signs:</label>
                    <button id="spawnStopSign" class=""><i class="fas fa-hand mr-2" style="color: red;"></i>Stop</button>
                    <button id="spawnTrafficLight" class=""><i class="fas fa-traffic-light mr-2"></i>Light</button>
                    <button id="spawnYield" class=""><i class="fas fa-exclamation-triangle mr-2"></i>Yield</button>
                </div>

                <div class="control-group">
                    <label><i class="fas fa-tree mr-2"></i>Obstacles:</label>
                    <button id="spawnBuilding"><i class="fas fa-building mr-2"></i>Building</button>
                    <button id="spawnTree"><i class="fas fa-tree mr-2"></i>Tree</button>
                    <button id="spawnPole"><i class="fas fa-road mr-2"></i>Pole</button>
                    <button id="spawnCone"><i class="fas fa-traffic-light mr-2"></i>Cone</button>
                    <button id="spawnBarrier"><i class="fas fa-shield mr-2"></i>Barrier</button>
                    <button id="spawnPothole"><i class="fas fa-circle mr-2"></i>Pothole</button>
                </div>

                <div class="control-group">
                    <label><i class="fas fa-cog mr-2"></i>Simulation:</label>
                    <button id="startStop" style="background: #0066cc;">Start</button>
                    <button id="deleteMode"><i class="fas fa-trash mr-2"></i>Delete</button>
                    <button id="clearAll"><i class="fas fa-eraser mr-2"></i>Clear</button>
                    <button id="toggleSensors" class="active"><i class="fas fa-eye mr-2"></i>Sensors</button>
                </div>
            </div>
            <div id="spawnHint" class="spawn-hint" style="display: none; text-align: center;">Click on canvas to place
                person</div>
        </div>

        <div class="output-section">
            <div class="output-panel">
                <h3>Real-Time AI Actions</h3>
                <ul class="action-log" id="actionLog">
                    <li class="warning">ðŸ”´ FRONT: 2 object(s)</li>
                    <li class="warning">â­• BACK: 3 object(s)</li>
                    <li class="warning">ðŸŸ¡ FRONT-LEFT: 1 object(s)</li>
                    <li class="critical">ðŸ”´ RED LIGHT - STOP AT LINE</li>
                    <li class="info">ðŸ›‘ STOP SIGN DETECTED AHEAD - APPROACH CAUTIOUSLY</li>
                    <li class="info">â„¹ TRUCK IN REAR - MONITOR</li>
                    <li class="info">â„¹ BUS IN REAR - MONITOR</li>
                    <li class="info">â„¹ CAR IN REAR - MONITOR</li>
                </ul>
            </div>

            <div class="stats">
                <div class="stat-row">
                    <span>Vehicle Speed:</span>
                    <span id="speedValue">0 km/h</span>
                </div>
                <div class="speed-indicator">
                    <div class="speed-fill" id="speedFill" style="width: 0%;"></div>
                </div>
                <div class="stat-row">
                    <span>Objects Detected:</span>
                    <span id="objectCount">8</span>
                </div>
                <div class="stat-row">
                    <span>Critical Threats:</span>
                    <span id="threatCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Nearest Distance:</span>
                    <span id="nearestDistance">188px</span>
                </div>
                <div class="stat-row">
                    <span>AI Status:</span>
                    <span id="status">SLOWING DOWN</span>
                </div>
            </div>

            <div class="traffic-light-control">
                <h3>Manual Traffic Light Control</h3>
                <div class="light-buttons">
                    <div class="light-btn red" id="lightRed" title="Red" style="border: 3px solid rgb(255, 255, 255);">
                    </div>
                    <div class="light-btn yellow" id="lightYellow" title="Yellow"
                        style="border: 2px solid rgb(102, 102, 102);"></div>
                    <div class="light-btn green" id="lightGreen" title="Green"
                        style="border: 2px solid rgb(102, 102, 102);"></div>
                </div>
            </div>

            <div class="ai-stats-advanced">
                <h4>Advanced AI Metrics</h4>
                <div class="ai-metric">
                    <span class="label">Decision Mode:</span>
                    <span id="aiMode" class="mode-indicator normal">NORMAL</span>
                </div>
                <div class="ai-metric">
                    <span class="label">Threat Level:</span>
                    <span id="threatLevel" class="value">LOW</span>
                </div>
                <div class="threat-bar">
                    <div class="threat-fill" id="threatFillBar" style="width: 0%;"></div>
                </div>
                <div class="ai-metric">
                    <span class="label">Reaction Time:</span>
                    <span id="reactionTime" class="value">0ms</span>
                </div>
                <div class="ai-metric">
                    <span class="label">Accuracy:</span>
                    <span id="detectionAccuracy" class="value">98%</span>
                </div>
                <div class="ai-metric">
                    <span class="label">Sensor Range:</span>
                    <span id="sensorRange" class="value">200px</span>
                </div>
            </div>

            <div class="prediction-panel">
                <h4>Predictive Behavior</h4>
                <div class="prediction-item">
                    <span>Collision Risk (5s):</span>
                    <span class="confidence" id="collisionRisk">0%</span>
                </div>
                <div class="prediction-item">
                    <span>Path Obstruction:</span>
                    <span class="confidence" id="pathObstruction">Clear</span>
                </div>
                <div class="prediction-item">
                    <span>Avg. Safe Distance:</span>
                    <span class="confidence" id="safeDistance">--</span>
                </div>
                <div class="prediction-item">
                    <span>Decision Confidence:</span>
                    <span class="confidence" id="decisionConfidence">95%</span>
                </div>
            </div>
        </div>
    </div>

    <div class="crash-overlay" id="crashOverlay"></div>
    <div class="crash-modal" id="crashModal">
        <h2>CRASHED</h2>
        <button id="restartBtn">RESET</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // ===== VEHICLE IMAGE CONFIGURATION (Edit these URLs) =====
        const VEHICLE_IMAGES = {
            mainVehicle: './car3.png',
            car: 'car2.png',
            bus: './bus.png',
            truck: './truck.png'
        };
        // =========================================================

        // Image cache for vehicles
        const imageCache = {
            car: null,
            bus: null,
            truck: null
        };

        // Function to load image from URL
        function loadVehicleImage(type, url) {
            if (!url) return;
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = function () {
                imageCache[type] = img;
                console.log(`âœ“ Loaded ${type} image`);
            };
            img.onerror = function () {
                console.warn(`âœ— Failed to load ${type} image from ${url}`);
            };
            img.src = url;
        }

        // Load vehicle images on startup
        function initializeVehicleImages() {
            if (VEHICLE_IMAGES.mainVehicle) loadVehicleImage('mainVehicle', VEHICLE_IMAGES.mainVehicle);
            if (VEHICLE_IMAGES.car) loadVehicleImage('car', VEHICLE_IMAGES.car);
            if (VEHICLE_IMAGES.bus) loadVehicleImage('bus', VEHICLE_IMAGES.bus);
            if (VEHICLE_IMAGES.truck) loadVehicleImage('truck', VEHICLE_IMAGES.truck);
        }

        // Initialize on startup
        initializeVehicleImages();

        // Resize canvas
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Road lanes (horizontal format)
        const lanes = [
            { y: canvas.height / 2 - 80, width: 80 },
            { y: canvas.height / 2, width: 80 },
            { y: canvas.height / 2 + 80, width: 80 }
        ];

        // Autonomous Vehicle with sensors
        const vehicle = {
            x: 100,
            y: canvas.height / 2,
            width: 80,
            height: 50,
            speed: 0,
            maxSpeed: 8,
            direction: 0,
            detectionRadius: 500,
            isStopped: false,
            actionQueue: [],
            emergencyBraking: false,
            currentLane: 1, // 0, 1, or 2
            laneChangeTime: 0,
            lastLaneChangeFrame: 0,
            laneChangeCooldown: 15, // frames before can change lane again
            isCrashed: false,
            crashFrame: 0,
            targetLane: 1, // desired lane for AI navigation
            reverseMode: false,
            lateralAvoidance: 0,
            sensors: {
                front: { detectedObjects: [] },
                frontLeft: { detectedObjects: [] },
                frontRight: { detectedObjects: [] },
                left: { detectedObjects: [] },
                right: { detectedObjects: [] },
                back: { detectedObjects: [] }
            }
        };

        // Simulation state
        let isRunning = false;
        let spawnMode = null;
        let deleteMode = false;
        const objects = [];
        let nextId = 0;
        let selectedTrafficLightColor = '#28a745';
        let frameCount = 0;
        let showSensors = true;
        let lastAutoSpawnFrame = 0;
         const autoSpawnInterval = 120; // frames between auto spawns
         const autoSpawnTypes = ['car', 'bus', 'truck'];

        class DrivingObject {
            constructor(type, x, y, speed = 0, laneIndex = null) {
                this.id = nextId++;
                this.type = type;
                this.x = x;
                this.y = y;
                this.speed = speed;
                this.direction = 0;
                this.targetX = x;
                this.targetY = y;
                this.laneIndex = laneIndex;
                this.isHit = false;
                this.hitFrame = 0;
                this.originalWidth = null;
                this.originalHeight = null;
                this.isCrashed = false;
                this.crashFrame = 0;
                this.crashParticles = [];
                this.name = null; // For named pedestrians

                // Set properties based on type
                switch (type) {
                    case 'car':
                        this.width = 80;
                        this.height = 50;
                        this.originalWidth = 80;
                        this.originalHeight = 50;
                        this.color = '#ff0000';
                        this.maxSpeed = 6;
                        break;
                    case 'person':
                        this.width = 12;
                        this.height = 30;
                        this.originalWidth = 12;
                        this.originalHeight = 30;
                        this.color = '#ff99ff';
                        this.maxSpeed = 2.5;
                        this.skinColor = '#f4a460';
                        this.clothColor = '#3366cc';
                        break;
                    case 'bus':
                        this.width = 110;
                        this.height = 55;
                        this.originalWidth = 110;
                        this.originalHeight = 55;
                        this.color = '#ffff00';
                        this.maxSpeed = 5;
                        break;
                    case 'truck':
                        this.width = 130;
                        this.height = 60;
                        this.originalWidth = 130;
                        this.originalHeight = 60;
                        this.color = '#ff6600';
                        this.maxSpeed = 4;
                        break;
                    case 'building':
                        this.width = 60;
                        this.height = 70;
                        this.color = '#8b4513';
                        this.maxSpeed = 0;
                        break;
                    case 'tree':
                        this.width = 20;
                        this.height = 50;
                        this.color = '#228b22';
                        this.maxSpeed = 0;
                        break;
                    case 'pole':
                        this.width = 8;
                        this.height = 60;
                        this.color = '#a9a9a9';
                        this.maxSpeed = 0;
                        break;
                    case 'stop sign':
                        this.width = 25;
                        this.height = 25;
                        this.color = '#ff0000';
                        this.maxSpeed = 0;
                        this.shape = 'octagon';
                        break;
                    case 'yield':
                        this.width = 20;
                        this.height = 20;
                        this.color = '#ff6600';
                        this.maxSpeed = 0;
                        this.shape = 'triangle';
                        break;
                    case 'traffic light':
                        this.width = 15;
                        this.height = 40;
                        this.color = '#0066cc';
                        this.lightColor = '#28a745';
                        this.maxSpeed = 0;
                        break;
                    case 'pothole':
                        this.width = 15;
                        this.height = 15;
                        this.color = '#333';
                        this.maxSpeed = 0;
                        break;
                    case 'cone':
                        this.width = 10;
                        this.height = 25;
                        this.color = '#ff8800';
                        this.maxSpeed = 0;
                        this.shape = 'cone';
                        break;
                    case 'barrier':
                        this.width = 50;
                        this.height = 15;
                        this.color = '#ffff00';
                        this.maxSpeed = 0;
                        break;
                }
            }

            update() {
                // Only move if simulation is running
                if (!isRunning) return true;

                // Handle crash state for vehicles
                if (this.isCrashed) {
                    this.crashFrame++;
                    const maxCrashFrames = 80;
                    const progress = this.crashFrame / maxCrashFrames;

                    // Shrink
                    this.width = this.originalWidth * (1 - progress);
                    this.height = this.originalHeight * (1 - progress);

                    // Delete after animation
                    if (this.crashFrame > maxCrashFrames) {
                        return false;
                    }
                    return true;
                }

                // Handle hit state for people
                if (this.isHit) {
                    this.hitFrame++;
                    const maxHitFrames = 60;
                    const progress = this.hitFrame / maxHitFrames;

                    // Shrink
                    this.width = this.originalWidth * (1 - progress);
                    this.height = this.originalHeight * (1 - progress);

                    // Delete after animation
                    if (this.hitFrame > maxHitFrames) {
                        return false;
                    }
                    return true;
                }

                // For lane vehicles, move along lane horizontally
                if (['car', 'bus', 'truck'].includes(this.type) && this.laneIndex !== null) {
                    this.y = lanes[this.laneIndex].y;

                    // Check for traffic signs and obstacles ahead
                    let shouldStop = false;
                    let shouldSlow = false;
                    const detectionDist = 200;

                    // Check for stop signs
                    for (const obj of objects) {
                        if (obj.type === 'stop sign') {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -detectionDist && Math.abs(this.y - obj.y) < 100) {
                                shouldStop = true;
                                break;
                            }
                        }
                    }

                    // Check for red/yellow traffic lights
                    for (const obj of objects) {
                        if (obj.type === 'traffic light') {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -detectionDist && Math.abs(this.y - obj.y) < 100) {
                                if (obj.lightColor === '#ff0000') {
                                    shouldStop = true;
                                    break;
                                } else if (obj.lightColor === '#ffaa00') {
                                    shouldSlow = true;
                                }
                            }
                        }
                    }

                    // Check for yield signs
                    for (const obj of objects) {
                        if (obj.type === 'yield') {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -detectionDist && Math.abs(this.y - obj.y) < 100) {
                                shouldSlow = true;
                            }
                        }
                    }

                    // Check for obstacles (building, tree, pole, cone, barrier, pothole)
                    for (const obj of objects) {
                        if (['building', 'tree', 'pole', 'cone', 'barrier', 'pothole'].includes(obj.type)) {
                            const dx = this.x - obj.x;
                            const dy = this.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const minDist = this.width + obj.width;
                            if (dist < minDist + 100 && dist > 0 && dx < 0) {
                                // Obstacle ahead
                                if (dist < minDist + 20) {
                                    shouldStop = true;
                                } else {
                                    shouldSlow = true;
                                }
                            }
                        }
                    }

                    // Check for other vehicles ahead
                    for (const obj of objects) {
                        if (obj.id === this.id) continue;
                        if (['car', 'bus', 'truck'].includes(obj.type) && obj.laneIndex === this.laneIndex) {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -150) {
                                // Vehicle ahead in same lane
                                if (Math.abs(dist) < 60) {
                                    shouldStop = true;
                                } else {
                                    shouldSlow = true;
                                }
                            }
                        }
                    }

                    // Check for main vehicle ahead
                    if (vehicle.currentLane === this.laneIndex) {
                        const dist = this.x - vehicle.x;
                        if (dist < 0 && dist > -150) {
                            if (Math.abs(dist) < 80) {
                                shouldStop = true;
                            } else {
                                shouldSlow = true;
                            }
                        }
                    }

                    // Apply speed control based on obstacles and signs
                    if (shouldStop) {
                        this.speed = 0;
                    } else if (shouldSlow) {
                        this.speed = Math.max(0, Math.min(this.speed - 0.3, this.maxSpeed * 0.3));
                    } else {
                        this.speed = Math.min(this.speed + 0.2, this.maxSpeed);
                    }

                    this.x += this.speed; // Move rightward (towards camera/viewer)

                    if (this.x > canvas.width + this.width) {
                        return false; // Mark for removal
                    }
                } else if (this.type === 'person') {
                    // People try to avoid obstacles and vehicles with panic behavior
                    if (Math.random() < 0.02) {
                        this.targetX = Math.random() * canvas.width;
                        this.targetY = Math.random() * canvas.height;
                    }

                    // Check for nearby vehicles and obstacles to avoid
                    let avoidX = 0;
                    let avoidY = 0;
                    const avoidRadius = 200;
                    const panicRadius = 80;
                    let isPanic = false;

                    // Avoid main vehicle - PANIC if very close
                    const vDx = this.x - vehicle.x;
                    const vDy = this.y - vehicle.y;
                    const vDist = Math.sqrt(vDx * vDx + vDy * vDy);
                    if (vDist < panicRadius && vDist > 0) {
                        // PANIC MODE - run away at max speed
                        isPanic = true;
                        avoidX += (vDx / vDist) * 2;
                        avoidY += (vDy / vDist) * 2;
                    } else if (vDist < avoidRadius && vDist > 0) {
                        avoidX += (vDx / vDist) * (1 - vDist / avoidRadius) * 1.5;
                        avoidY += (vDy / vDist) * (1 - vDist / avoidRadius) * 1.5;
                    }

                    // Avoid other objects (vehicles, buildings, obstacles, etc.)
                    for (const obj of objects) {
                        if (obj.id === this.id) continue;
                        if (['car', 'bus', 'truck', 'building', 'tree', 'pole', 'cone', 'barrier', 'pothole'].includes(obj.type)) {
                            const dx = this.x - obj.x;
                            const dy = this.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const minSafeDistance = 60;
                            if (dist < avoidRadius && dist > 0) {
                                const forceMultiplier = dist < minSafeDistance ? 2 : 1;
                                avoidX += (dx / dist) * (1 - dist / avoidRadius) * forceMultiplier;
                                avoidY += (dy / dist) * (1 - dist / avoidRadius) * forceMultiplier;
                                if (dist < minSafeDistance) {
                                    isPanic = true;
                                }
                            }
                        }
                    }

                    // Avoid other people
                    for (const obj of objects) {
                        if (obj.id === this.id) continue;
                        if (obj.type === 'person') {
                            const dx = this.x - obj.x;
                            const dy = this.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 50 && dist > 0) {
                                avoidX += (dx / dist) * (1 - dist / 50) * 0.5;
                                avoidY += (dy / dist) * (1 - dist / 50) * 0.5;
                            }
                        }
                    }

                    const dx = this.targetX - this.x + avoidX * (isPanic ? 150 : 100);
                    const dy = this.targetY - this.y + avoidY * (isPanic ? 150 : 100);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 5) {
                        const targetSpeed = isPanic ? this.maxSpeed : Math.min(this.speed + 0.1, this.maxSpeed);
                        this.speed = targetSpeed;
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    } else {
                        this.speed = isPanic ? 0 : Math.max(0, this.speed - 0.2);
                    }

                    this.x = Math.max(this.width / 2, Math.min(canvas.width - this.width / 2, this.x));
                    this.y = Math.max(this.height / 2, Math.min(canvas.height - this.height / 2, this.y));
                } else if (this.type === 'traffic light') {
                    this.lightColor = selectedTrafficLightColor;
                }

                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Change color based on state
                let drawColor = this.color;
                if (this.isCrashed) {
                    // Red/orange for crash with flickering
                    const flicker = Math.sin(this.crashFrame * 0.3) > 0 ? 0.5 : 1;
                    drawColor = `rgba(255, ${Math.floor(100 * flicker)}, 0, ${1 - (this.crashFrame / 80) * 0.5})`;
                } else if (this.isHit) {
                    drawColor = '#999999';
                }

                if (this.shape === 'octagon') {
                    drawOctagon(ctx, this.width / 2, drawColor);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('STOP', 0, 0);
                } else if (this.shape === 'triangle') {
                    drawTriangle(ctx, this.width / 2, drawColor);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('YIELD', 0, 3);
                } else if (this.type === 'traffic light') {
                    // Realistic traffic light box
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);

                    // Draw lights with glow
                    const lightGlow = (color) => {
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 8;
                    };
                    ctx.shadowColor = 'rgba(0,0,0,0)';
                    ctx.shadowBlur = 0;

                    // Red light
                    ctx.fillStyle = this.lightColor === '#ff0000' ? '#ff0000' : '#330000';
                    if (this.lightColor === '#ff0000') {
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 6;
                    }
                    ctx.beginPath();
                    ctx.arc(0, -12, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Yellow light
                    ctx.fillStyle = this.lightColor === '#ffaa00' ? '#ffaa00' : '#333300';
                    ctx.shadowColor = this.lightColor === '#ffaa00' ? '#ffaa00' : 'rgba(0,0,0,0)';
                    ctx.shadowBlur = this.lightColor === '#ffaa00' ? 6 : 0;
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Green light
                    ctx.fillStyle = this.lightColor === '#28a745' ? '#28a745' : '#003300';
                    ctx.shadowColor = this.lightColor === '#28a745' ? '#28a745' : 'rgba(0,0,0,0)';
                    ctx.shadowBlur = this.lightColor === '#28a745' ? 6 : 0;
                    ctx.beginPath();
                    ctx.arc(0, 12, 5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowColor = 'rgba(0,0,0,0)';
                    ctx.shadowBlur = 0;
                } else if (this.type === 'person') {
                    // Realistic person with head and body
                    // Head
                    ctx.fillStyle = this.skinColor;
                    ctx.beginPath();
                    ctx.arc(0, -12, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // Body
                    ctx.fillStyle = this.clothColor;
                    ctx.fillRect(-4, -7, 8, 14);
                    // Legs
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-2, 7);
                    ctx.lineTo(-2, 15);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(2, 7);
                    ctx.lineTo(2, 15);
                    ctx.stroke();
                } else if (this.type === 'building') {
                    // Realistic building with windows
                    ctx.fillStyle = '#8b5a2b';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    // Windows
                    ctx.fillStyle = '#ffeb99';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 4; j++) {
                            ctx.fillRect(-this.width / 2 + 10 + i * 15, -this.height / 2 + 10 + j * 15, 5, 5);
                        }
                    }
                } else if (this.type === 'tree') {
                    // Realistic tree
                    ctx.fillStyle = '#8b6914';
                    ctx.fillRect(-3, 5, 6, 20);
                    ctx.fillStyle = '#228b22';
                    ctx.beginPath();
                    ctx.arc(0, -5, 12, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'pole') {
                    // Realistic pole
                    ctx.fillStyle = '#666';
                    ctx.fillRect(-2, -25, 4, 50);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-2, -25, 4, 50);
                } else if (this.type === 'car') {
                    // Draw car image if available, otherwise draw default
                    if (imageCache.car && !this.isCrashed) {
                        ctx.drawImage(imageCache.car, -this.width / 2, -this.height / 2, this.width, this.height);
                    } else {
                        // Fallback: default car drawing
                        ctx.fillStyle = drawColor;
                        ctx.fillRect(-this.width / 2, -this.height / 2 + 2, this.width, this.height - 4);
                        ctx.fillStyle = this.color === '#0066cc' ? '#004499' : '#993333';
                        ctx.fillRect(-this.width / 3, -this.height / 2 + 2, this.width * 0.66, this.height / 2);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1.5;
                        ctx.strokeRect(-this.width / 2, -this.height / 2 + 2, this.width, this.height - 4);
                    }
                } else if (this.type === 'bus') {
                    // Draw bus image if available, otherwise draw default
                    if (imageCache.bus && !this.isCrashed) {
                        ctx.drawImage(imageCache.bus, -this.width / 2, -this.height / 2, this.width, this.height);
                    } else {
                        // Fallback: default bus drawing
                        ctx.fillStyle = drawColor;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    }
                } else if (this.type === 'truck') {
                    // Draw truck image if available, otherwise draw default
                    if (imageCache.truck && !this.isCrashed) {
                        ctx.drawImage(imageCache.truck, -this.width / 2, -this.height / 2, this.width, this.height);
                    } else {
                        // Fallback: default truck drawing
                        ctx.fillStyle = drawColor;
                        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    }
                } else if (this.type === 'pothole') {
                    // Pothole (dark circular depression)
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    // Shadow inside
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 2, this.width / 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'cone') {
                    // Traffic cone
                    ctx.fillStyle = drawColor;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height / 2);
                    ctx.lineTo(this.width / 2, this.height / 2);
                    ctx.lineTo(-this.width / 2, this.height / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    // Reflective stripes
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-this.width / 4, -5);
                    ctx.lineTo(this.width / 4, 5);
                    ctx.stroke();
                } else if (this.type === 'barrier') {
                    // Construction barrier - HORIZONTAL (facing direction of traffic)
                    ctx.fillStyle = drawColor;
                    // Draw wider horizontal barrier (50Ã—15 = wider than tall)
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

                    // Black and yellow diagonal stripes for visibility
                    ctx.fillStyle = '#000';
                    ctx.lineWidth = 2;

                    // Diagonal stripes
                    for (let i = -2; i < this.width / 8; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-this.width / 2 + i * 8, -this.height / 2);
                        ctx.lineTo(-this.width / 2 + i * 8 + this.height, this.height / 2);
                        ctx.stroke();
                    }

                    // Border
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);

                    // Reflective end caps
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.width / 2 - 2, -this.height / 2, 4, this.height);  // Right end cap
                    ctx.fillRect(-this.width / 2 - 2, -this.height / 2, 4, this.height);  // Left end cap
                } else {
                    ctx.fillStyle = drawColor;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                }

                // Draw explosion effect during crash
                if (this.isCrashed && this.crashFrame < 60) {
                    const numParticles = 8;
                    for (let i = 0; i < numParticles; i++) {
                        const angle = (i / numParticles) * Math.PI * 2;
                        const distance = (this.crashFrame / 60) * 80;
                        const particleX = Math.cos(angle) * distance;
                        const particleY = Math.sin(angle) * distance;

                        ctx.fillStyle = `rgba(255, ${Math.floor(150 - this.crashFrame)}, 0, ${1 - (this.crashFrame / 60)})`;
                        ctx.beginPath();
                        const particleSize = 6 - (this.crashFrame / 60) * 4;
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw name label for named pedestrians
                if (this.name && this.type === 'person') {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(this.name, 0, -this.height / 2 - 5);
                }

                ctx.restore();
            }

            getDistance(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            getArea() {
                return this.width * this.height;
            }
        }

        function checkPersonVehicleCollisions() {
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                if (obj.type === 'person' && !obj.isHit) {
                    // Check collision with main vehicle
                    const dx = obj.x - vehicle.x;
                    const dy = obj.y - vehicle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (obj.width + vehicle.width) / 2;

                    if (dist < minDist) {
                        obj.isHit = true;
                        obj.hitFrame = 0;
                    }

                    // Check collision with other vehicles
                    for (let j = 0; j < objects.length; j++) {
                        if (i === j) continue;
                        const vehicleObj = objects[j];
                        if (['car', 'bus', 'truck'].includes(vehicleObj.type)) {
                            const dx = obj.x - vehicleObj.x;
                            const dy = obj.y - vehicleObj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const minDist = (obj.width + vehicleObj.width) / 2;

                            if (dist < minDist) {
                                obj.isHit = true;
                                obj.hitFrame = 0;
                            }
                        }
                    }
                }
            }
        }

        function checkVehicleCollisions() {
            // Check collisions between vehicles (car, bus, truck)
            for (let i = 0; i < objects.length; i++) {
                const obj1 = objects[i];
                if (['car', 'bus', 'truck'].includes(obj1.type) && !obj1.isCrashed) {
                    // Check collision with main vehicle
                    if (!vehicle.isCrashed) {
                        const dx = obj1.x - vehicle.x;
                        const dy = obj1.y - vehicle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = (obj1.width + vehicle.width) / 2;
                        // Only collide if in same lane (within lane width)
                        const laneDiff = Math.abs(obj1.y - vehicle.y);
                        const laneThreshold = 50; // Allow some tolerance for same lane

                        if (dist < minDist && laneDiff < laneThreshold) {
                            // Both vehicles crash
                            obj1.isCrashed = true;
                            obj1.crashFrame = 0;
                            vehicle.isCrashed = true;
                            vehicle.crashFrame = 0;
                            showCrashModal();
                        }
                    }

                    // Check collision with other vehicles
                    for (let j = 0; j < objects.length; j++) {
                        if (i === j) continue;
                        const obj2 = objects[j];
                        if (['car', 'bus', 'truck'].includes(obj2.type) && !obj2.isCrashed) {
                            const dx = obj1.x - obj2.x;
                            const dy = obj1.y - obj2.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const minDist = (obj1.width + obj2.width) / 2;
                            // Only collide if in same lane (within lane width)
                            const laneDiff = Math.abs(obj1.y - obj2.y);
                            const laneThreshold = 50; // Allow some tolerance for same lane

                            if (dist < minDist && laneDiff < laneThreshold) {
                                // Both vehicles crash
                                obj1.isCrashed = true;
                                obj1.crashFrame = 0;
                                obj2.isCrashed = true;
                                obj2.crashFrame = 0;
                            }
                        }
                    }
                }
            }
        }

        function showCrashModal() {
            document.getElementById('crashOverlay').style.display = 'block';
            document.getElementById('crashModal').style.display = 'block';
            isRunning = false;
            document.getElementById('startStop').textContent = 'Start';
            document.getElementById('startStop').style.background = '#0066cc';
        }

        function hideCrashModal() {
            document.getElementById('crashOverlay').style.display = 'none';
            document.getElementById('crashModal').style.display = 'none';
        }

        function restartVehicle() {
            hideCrashModal();
            vehicle.x = 100;
            vehicle.y = lanes[1].y;
            vehicle.speed = 0;
            vehicle.isCrashed = false;
            vehicle.crashFrame = 0;
            vehicle.isStopped = false;
            vehicle.emergencyBraking = false;
            vehicle.currentLane = 1;
            vehicle.actionQueue = [];
            vehicle.sensors = {
                front: { detectedObjects: [] },
                frontLeft: { detectedObjects: [] },
                frontRight: { detectedObjects: [] },
                left: { detectedObjects: [] },
                right: { detectedObjects: [] },
                back: { detectedObjects: [] }
            };
        }

        function detonateBomb(bombX, bombY) {
            const explosionRadius = 200;

            // Crash main vehicle if in range
            if (!vehicle.isCrashed) {
                const dx = vehicle.x - bombX;
                const dy = vehicle.y - bombY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < explosionRadius) {
                    vehicle.isCrashed = true;
                    vehicle.crashFrame = 0;
                }
            }

            // Crash all objects in radius
            for (let i = 0; i < objects.length; i++) {
                const obj = objects[i];
                const dx = obj.x - bombX;
                const dy = obj.y - bombY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < explosionRadius) {
                    if (['car', 'bus', 'truck'].includes(obj.type) && !obj.isCrashed) {
                        obj.isCrashed = true;
                        obj.crashFrame = 0;
                    } else if (obj.type === 'person' && !obj.isHit) {
                        obj.isHit = true;
                        obj.hitFrame = 0;
                    }
                }
            }
        }

        function drawOctagon(ctx, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawTriangle(ctx, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, -radius);
            ctx.lineTo(radius, radius);
            ctx.lineTo(-radius, radius);
            ctx.closePath();
            ctx.fill();
        }

        // Enhanced AI Detection logic with predictive analysis
        function detectObjects() {
            // Clear all sensors
            vehicle.sensors.front.detectedObjects = [];
            vehicle.sensors.frontLeft.detectedObjects = [];
            vehicle.sensors.frontRight.detectedObjects = [];
            vehicle.sensors.left.detectedObjects = [];
            vehicle.sensors.right.detectedObjects = [];
            vehicle.sensors.back.detectedObjects = [];

            const imageArea = canvas.width * canvas.height;
            const sensorLength = 200;

            for (const obj of objects) {
                const dx = obj.x - vehicle.x;
                const dy = obj.y - vehicle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > vehicle.detectionRadius) continue;

                const area = obj.getArea();
                const occupancy = (area / imageArea) * 100;

                // Enhanced distance calculation with velocity prediction
                let distanceLevel = 'SAFE';
                let predictedDistance = dist;

                // Predict where object will be in 30 frames (enhanced AI)
                if (obj.speed > 0) {
                    const directionX = obj.speed * Math.cos(obj.direction || 0);
                    const directionY = obj.speed * Math.sin(obj.direction || 0);
                    const predictedX = obj.x + (directionX * 30);
                    const predictedY = obj.y + (directionY * 30);
                    const predictedDx = predictedX - vehicle.x;
                    const predictedDy = predictedY - vehicle.y;
                    predictedDistance = Math.sqrt(predictedDx * predictedDx + predictedDy * predictedDy);
                }

                // Use the more critical of current or predicted distance
                const effectiveDistance = Math.min(dist, predictedDistance);

                // Distance levels with hysteresis for stability (increased thresholds for safer driving)
                if (effectiveDistance < 80) {
                    distanceLevel = 'CRITICAL';
                } else if (effectiveDistance < 140) {
                    distanceLevel = 'WARNING';
                } else if (effectiveDistance < 220) {
                    distanceLevel = 'MODERATE';
                } else if (effectiveDistance < 300) {
                    distanceLevel = 'OKAY';
                }

                // Check if object is moving towards vehicle (closing velocity)
                const closingVelocity = obj.speed > 0 ? 'moving' : 'stationary';

                const detection = {
                    obj: obj,
                    distance: dist,
                    predictedDistance: predictedDistance,
                    effectiveDistance: effectiveDistance,
                    distanceLevel: distanceLevel,
                    occupancy: occupancy,
                    closingVelocity: closingVelocity,
                    objectSpeed: obj.speed || 0
                };

                // Determine which sensor detected this object based on position relative to vehicle
                // More sophisticated sensor placement for better lane detection
                if (dx > 20) { // Object is ahead (vehicle moving right)
                    if (Math.abs(dy) < 40) { // Center lane (tighter)
                        vehicle.sensors.front.detectedObjects.push(detection);
                    } else if (dy < -40) { // Upper lanes
                        vehicle.sensors.frontLeft.detectedObjects.push(detection);
                    } else if (dy > 40) { // Lower lanes
                        vehicle.sensors.frontRight.detectedObjects.push(detection);
                    }
                } else if (dx < -20) { // Object is behind
                    vehicle.sensors.back.detectedObjects.push(detection);
                } else { // Object is beside
                    if (dy < 0) {
                        vehicle.sensors.left.detectedObjects.push(detection);
                    } else {
                        vehicle.sensors.right.detectedObjects.push(detection);
                    }
                }
            }

            // Sort detections by distance for priority handling
            vehicle.sensors.front.detectedObjects.sort((a, b) => a.distance - b.distance);
            vehicle.sensors.back.detectedObjects.sort((a, b) => a.distance - b.distance);
            vehicle.sensors.frontLeft.detectedObjects.sort((a, b) => a.distance - b.distance);
            vehicle.sensors.frontRight.detectedObjects.sort((a, b) => a.distance - b.distance);
        }

        // Check if obstacle is moving
        function isObjectMoving(obj) {
            return obj.speed > 0.5;
        }

        // AI Actions from amv.py logic with sensor awareness
        function getAction() {
            const actions = [];
            let threatLevel = 'safe';
            let blockingFront = false;
            let blockingBack = false;
            let redLightBlocking = false; // Don't allow lane change for red lights

            // FRONT SENSOR - Most critical
            for (const detection of vehicle.sensors.front.detectedObjects) {
                const obj = detection.obj;
                const distanceLevel = detection.distanceLevel;

                if (['car', 'bus', 'truck'].includes(obj.type)) {
                    if (distanceLevel === 'CRITICAL') {
                        threatLevel = 'critical';
                        blockingFront = true;
                        actions.push({
                            type: 'CRITICAL',
                            text: `âš  EMERGENCY - ${obj.type.toUpperCase()} AHEAD CRITICAL - BRAKE IMMEDIATELY`,
                            priority: 1
                        });
                    } else if (distanceLevel === 'WARNING') {
                        if (threatLevel !== 'critical') threatLevel = 'warning';
                        blockingFront = true;
                        actions.push({
                            type: 'WARNING',
                            text: `âš  DANGER - ${obj.type.toUpperCase()} AHEAD - REDUCE SPEED`,
                            priority: 2
                        });
                    } else if (distanceLevel === 'MODERATE') {
                        if (threatLevel === 'safe') threatLevel = 'caution';
                        actions.push({
                            type: 'INFO',
                            text: `â†’ CAUTION - ${obj.type.toUpperCase()} AHEAD - MAINTAIN DISTANCE`,
                            priority: 3
                        });
                    } else if (distanceLevel === 'OKAY') {
                        actions.push({
                            type: 'INFO',
                            text: `â„¹ ${obj.type.toUpperCase()} AHEAD - MONITOR`,
                            priority: 4
                        });
                    }
                } else if (obj.type === 'person') {
                    if (distanceLevel === 'CRITICAL') {
                        threatLevel = 'critical';
                        blockingFront = true;
                        actions.push({
                            type: 'CRITICAL',
                            text: 'ðŸš¨ EMERGENCY - PEDESTRIAN CRITICAL RANGE - BRAKE IMMEDIATELY',
                            priority: 1
                        });
                    } else if (distanceLevel === 'WARNING') {
                        if (threatLevel !== 'critical') threatLevel = 'warning';
                        blockingFront = true;
                        actions.push({
                            type: 'WARNING',
                            text: 'âš  DANGER - PEDESTRIAN AHEAD - REDUCE SPEED',
                            priority: 2
                        });
                    } else if (distanceLevel === 'MODERATE') {
                        if (threatLevel === 'safe') threatLevel = 'caution';
                        actions.push({
                            type: 'INFO',
                            text: 'â†’ CAUTION - PEDESTRIAN AHEAD - MONITOR',
                            priority: 3
                        });
                    }
                } else if (['building', 'tree', 'pole', 'cone', 'barrier', 'pothole'].includes(obj.type)) {
                    if (distanceLevel === 'CRITICAL' || distanceLevel === 'WARNING') {
                        if (threatLevel !== 'critical') threatLevel = 'warning';
                        blockingFront = true;
                        const typeLabel = obj.type === 'pothole' ? 'POTHOLE' : obj.type.toUpperCase();
                        actions.push({
                            type: 'CRITICAL',
                            text: `âš  EMERGENCY - ${typeLabel} AHEAD - BRAKE/AVOID`,
                            priority: 1
                        });
                    } else if (distanceLevel === 'MODERATE') {
                        if (threatLevel !== 'critical') threatLevel = 'caution';
                        const typeLabel = obj.type === 'pothole' ? 'POTHOLE' : obj.type.toUpperCase();
                        actions.push({
                            type: 'INFO',
                            text: `â†’ CAUTION - ${typeLabel} AHEAD - AVOID/SLOW`,
                            priority: 3
                        });
                    } else if (distanceLevel === 'OKAY') {
                        const typeLabel = obj.type === 'pothole' ? 'POTHOLE' : obj.type.toUpperCase();
                        actions.push({
                            type: 'INFO',
                            text: `â„¹ ${typeLabel} DETECTED - MONITOR`,
                            priority: 4
                        });
                    }
                } else if (obj.type === 'stop sign') {
                    if (distanceLevel === 'CRITICAL' || distanceLevel === 'WARNING') {
                        if (threatLevel !== 'critical') threatLevel = 'warning';
                        blockingFront = true;
                        actions.push({
                            type: 'CRITICAL',
                            text: 'ðŸ›‘ STOP SIGN - COME TO HALT',
                            priority: 1
                        });
                    } else if (distanceLevel === 'MODERATE' || distanceLevel === 'OKAY') {
                        actions.push({
                            type: 'INFO',
                            text: 'ðŸ›‘ STOP SIGN DETECTED AHEAD - APPROACH CAUTIOUSLY',
                            priority: 3
                        });
                    }
                } else if (obj.type === 'traffic light') {
                    if (obj.lightColor === '#ff0000') {
                        // Red light blocks forward movement but doesn't set threat level
                        // This allows the car to reverse if blocked, even at a red light
                        blockingFront = true;
                        redLightBlocking = true; // Flag to prevent lane changes and forward movement
                        actions.push({
                            type: 'CRITICAL',
                            text: 'ðŸ”´ RED LIGHT - STOP AT LINE',
                            priority: 1
                        });
                    } else if (obj.lightColor === '#ffaa00') {
                        if (threatLevel === 'safe') threatLevel = 'caution';
                        actions.push({
                            type: 'WARNING',
                            text: 'ðŸŸ¡ YELLOW LIGHT - SLOW DOWN - PREPARE TO STOP',
                            priority: 2
                        });
                    } else if (obj.lightColor === '#28a745') {
                        actions.push({
                            type: 'INFO',
                            text: 'ðŸŸ¢ GREEN LIGHT - PROCEED WITH CAUTION',
                            priority: 3
                        });
                    }
                } else if (obj.type === 'yield') {
                    if (distanceLevel === 'CRITICAL' || distanceLevel === 'WARNING') {
                        if (threatLevel !== 'critical') threatLevel = 'warning';
                        blockingFront = true;
                        actions.push({
                            type: 'WARNING',
                            text: 'ðŸš§ YIELD SIGN - LET OTHERS PASS',
                            priority: 2
                        });
                    } else if (distanceLevel === 'MODERATE' || distanceLevel === 'OKAY') {
                        actions.push({
                            type: 'INFO',
                            text: 'ðŸš§ YIELD SIGN AHEAD - PREPARE TO YIELD',
                            priority: 3
                        });
                    }
                }
            }

            // BACK SENSOR - Only care about obstacles, not signs
            for (const detection of vehicle.sensors.back.detectedObjects) {
                const obj = detection.obj;
                // Only process actual obstacles in back, ignore traffic signs/lights
                if (['car', 'bus', 'truck', 'person'].includes(obj.type)) {
                    if (detection.distanceLevel === 'CRITICAL' || detection.distanceLevel === 'WARNING') {
                        blockingBack = true;
                        actions.push({
                            type: 'INFO',
                            text: `â„¹ ${obj.type.toUpperCase()} IN REAR - CANNOT REVERSE`,
                            priority: 4
                        });
                    } else {
                        actions.push({
                            type: 'INFO',
                            text: `â„¹ ${obj.type.toUpperCase()} IN REAR - MONITOR`,
                            priority: 5
                        });
                    }
                }
            }

            // Check for side obstacles blocking lane change
            const sideBlockFrontLeft = vehicle.sensors.frontLeft.detectedObjects.some(d => ['car', 'bus', 'truck', 'person'].includes(d.obj.type) && (d.distanceLevel === 'CRITICAL' || d.distanceLevel === 'WARNING' || d.distanceLevel === 'MODERATE'));
            const sideBlockFrontRight = vehicle.sensors.frontRight.detectedObjects.some(d => ['car', 'bus', 'truck', 'person'].includes(d.obj.type) && (d.distanceLevel === 'CRITICAL' || d.distanceLevel === 'WARNING' || d.distanceLevel === 'MODERATE'));

            return {
                actions: actions.sort((a, b) => a.priority - b.priority),
                threatLevel,
                blockingFront,
                blockingBack,
                sideBlockFrontLeft,
                sideBlockFrontRight,
                redLightBlocking
            };
        }

        function updateVehicleControl() {
            // Don't update if crashed
            if (vehicle.isCrashed) {
                vehicle.crashFrame++;
                return;
            }

            const { actions, threatLevel, blockingFront, blockingBack, sideBlockFrontLeft, sideBlockFrontRight, redLightBlocking } = getAction();
            vehicle.actionQueue = actions;

            // Speed control with intelligent movement (forward/reverse to avoid obstacles)
            if (threatLevel === 'critical') {
                vehicle.emergencyBraking = true;

                // If blocked in front and can't change lanes, reverse to create space
                if (blockingFront && sideBlockFrontLeft && sideBlockFrontRight) {
                    vehicle.speed = Math.max(-vehicle.maxSpeed * 0.3, vehicle.speed - 1.5); // Shift into reverse
                    document.getElementById('status').textContent = 'REVERSING - STUCK';
                } else {
                    vehicle.speed = Math.max(0, vehicle.speed - 1.0); // Hard brake
                    document.getElementById('status').textContent = 'EMERGENCY STOP';
                }
                vehicle.isStopped = Math.abs(vehicle.speed) < 0.1;
            } else if (threatLevel === 'warning') {
                // If blocked in front and sides blocked, reverse to escape
                if (blockingFront && sideBlockFrontLeft && sideBlockFrontRight && vehicle.speed < 0.5) {
                    vehicle.speed = Math.max(-vehicle.maxSpeed * 0.2, vehicle.speed - 0.4);
                    document.getElementById('status').textContent = 'BACKING UP SLOWLY';
                } else {
                    // Aggressive braking when warning threat detected
                    vehicle.speed = Math.max(0, vehicle.speed - 0.8);
                    document.getElementById('status').textContent = 'SLOWING DOWN';
                }
                vehicle.isStopped = Math.abs(vehicle.speed) < 0.1;
            } else if (threatLevel === 'caution') {
                vehicle.emergencyBraking = false;
                // If obstacle moderately close and can't change lanes, reverse gently
                if (blockingFront && sideBlockFrontLeft && sideBlockFrontRight) {
                    vehicle.speed = Math.max(-vehicle.maxSpeed * 0.1, vehicle.speed - 0.15);
                    document.getElementById('status').textContent = 'BACKING UP GENTLY';
                } else {
                    // Reduce speed more aggressively at caution level
                    vehicle.speed = Math.max(0, vehicle.speed - 0.3);
                    vehicle.speed = Math.min(vehicle.speed, vehicle.maxSpeed * 0.5);
                    document.getElementById('status').textContent = 'CAUTIOUS SPEED';
                }
            } else {
                vehicle.emergencyBraking = false;
                // Resume forward motion if was reversing and path is clear
                if (vehicle.speed < 0) {
                    vehicle.speed = Math.min(vehicle.speed + 0.2, 0); // Stop reversing gently
                } else {
                    vehicle.speed = Math.min(vehicle.speed + 0.12, vehicle.maxSpeed);
                }
                vehicle.isStopped = Math.abs(vehicle.speed) < 0.1;
                document.getElementById('status').textContent = 'NORMAL OPERATION';
            }

            // SMART LANE CHANGING with predictive analysis - Evaluate all lanes and pick the best one
            // Prioritize obstacles and maintain smooth driving
            if (blockingFront && !redLightBlocking && vehicle.speed > 0.5 && frameCount - vehicle.lastLaneChangeFrame > vehicle.laneChangeCooldown) {
                // Score each lane (lower is better) with enhanced metrics
                const lanes_info = [
                    {
                        lane: 0,
                        name: 'left',
                        blocked: sideBlockFrontLeft,
                        threat: vehicle.sensors.frontLeft.detectedObjects.length > 0 ?
                            Math.min(...vehicle.sensors.frontLeft.detectedObjects.map(d => d.effectiveDistance)) : 999
                    },
                    {
                        lane: 1,
                        name: 'center',
                        blocked: blockingFront,
                        threat: vehicle.sensors.front.detectedObjects.length > 0 ?
                            Math.min(...vehicle.sensors.front.detectedObjects.map(d => d.effectiveDistance)) : 999
                    },
                    {
                        lane: 2,
                        name: 'right',
                        blocked: sideBlockFrontRight,
                        threat: vehicle.sensors.frontRight.detectedObjects.length > 0 ?
                            Math.min(...vehicle.sensors.frontRight.detectedObjects.map(d => d.effectiveDistance)) : 999
                    }
                ];

                // Find available lanes (prefer lanes with greater threat distance)
                const availableLanes = lanes_info.filter(l => !l.blocked).sort((a, b) => b.threat - a.threat);

                if (availableLanes.length > 0) {
                    // Prefer middle lane for stability if safe, then furthest threat lane
                    let bestLane = vehicle.currentLane;

                    if (availableLanes.some(l => l.lane === 1 && !l.blocked)) {
                        bestLane = 1; // Prefer center lane if available
                    } else {
                        // Choose lane with highest threat distance (safest)
                        bestLane = availableLanes[0].lane;
                    }

                    if (bestLane !== vehicle.currentLane) {
                        vehicle.currentLane = bestLane;
                        vehicle.lastLaneChangeFrame = frameCount;
                    }
                }
            }

            // Smooth lateral movement to target lane with slight sway
            vehicle.lateralAvoidance = vehicle.lateralAvoidance * 0.95; // Damping
            vehicle.y = lanes[vehicle.currentLane].y + vehicle.lateralAvoidance;

            // Vehicle movement (horizontal - moving forward on road)
            // Red light blocks forward movement but allows reverse to escape obstacles
            if (vehicle.speed > 0) {
                // Forward movement - blocked by red lights
                if (redLightBlocking) {
                    vehicle.speed = 0; // Stop at red light
                } else {
                    vehicle.x += vehicle.speed;
                    if (vehicle.x > canvas.width) {
                        vehicle.x = 0;
                    }
                }
            } else if (vehicle.speed < 0 && !blockingBack && Math.abs(vehicle.speed) > 0.5) {
                // Reverse movement - always allowed (red lights don't block backing up)
                vehicle.x += vehicle.speed;
            } else if (vehicle.speed > 0.05) {
                // Minimal forward creep - still blocked by red lights
                if (!redLightBlocking) {
                    vehicle.x += vehicle.speed * 0.3;
                }
            } else {
                vehicle.speed = 0; // Full stop
            }
        }

        function updateActionLog() {
            const log = document.getElementById('actionLog');
            log.innerHTML = '';

            // Debug info - show sensor readings
            const debugInfo = [];
            if (vehicle.sensors.front.detectedObjects.length > 0) {
                debugInfo.push(`ðŸ”´ FRONT: ${vehicle.sensors.front.detectedObjects.length} object(s)`);
            }
            if (vehicle.sensors.back.detectedObjects.length > 0) {
                debugInfo.push(`â­• BACK: ${vehicle.sensors.back.detectedObjects.length} object(s)`);
            }
            if (vehicle.sensors.frontLeft.detectedObjects.length > 0) {
                debugInfo.push(`ðŸŸ¡ FRONT-LEFT: ${vehicle.sensors.frontLeft.detectedObjects.length} object(s)`);
            }
            if (vehicle.sensors.frontRight.detectedObjects.length > 0) {
                debugInfo.push(`ðŸŸ¢ FRONT-RIGHT: ${vehicle.sensors.frontRight.detectedObjects.length} object(s)`);
            }

            for (const info of debugInfo) {
                const li = document.createElement('li');
                li.className = 'warning';
                li.textContent = info;
                log.appendChild(li);
            }

            if (vehicle.actionQueue.length === 0 && debugInfo.length === 0) {
                const li = document.createElement('li');
                li.className = 'info';
                li.textContent = 'âœ“ All clear - Safe to proceed';
                log.appendChild(li);
            } else {
                for (const action of vehicle.actionQueue.slice(0, 5)) {
                    const li = document.createElement('li');
                    li.className = action.type === 'CRITICAL' ? 'critical' :
                        action.type === 'WARNING' ? 'warning' : 'info';
                    li.textContent = action.text;
                    log.appendChild(li);
                }
            }
        }

        // Advanced AI Metrics update
        function updateAdvancedAIMetrics() {
            // Calculate AI mode
            let mode = 'NORMAL';
            let modeClass = 'normal';

            const totalDetections =
                vehicle.sensors.front.detectedObjects.length +
                vehicle.sensors.back.detectedObjects.length +
                vehicle.sensors.frontLeft.detectedObjects.length +
                vehicle.sensors.frontRight.detectedObjects.length;

            if (vehicle.isStopped) {
                mode = 'STOPPED';
            } else if (vehicle.emergencyBraking) {
                mode = 'EMERGENCY';
                modeClass = 'aggressive';
            } else if (vehicle.speed < vehicle.maxSpeed * 0.4) {
                mode = 'CAUTIOUS';
                modeClass = 'cautious';
            }

            document.getElementById('aiMode').textContent = mode;
            document.getElementById('aiMode').className = `mode-indicator ${modeClass}`;

            // Calculate threat level percentage
            let threatLevel = 0;
            let threatText = 'LOW';

            for (const detection of vehicle.sensors.front.detectedObjects) {
                if (detection.distanceLevel === 'CRITICAL') threatLevel = 100;
                else if (detection.distanceLevel === 'WARNING') threatLevel = Math.max(threatLevel, 75);
                else if (detection.distanceLevel === 'MODERATE') threatLevel = Math.max(threatLevel, 50);
                else threatLevel = Math.max(threatLevel, 25);
            }

            if (threatLevel >= 75) threatText = 'CRITICAL';
            else if (threatLevel >= 50) threatText = 'HIGH';
            else if (threatLevel >= 25) threatText = 'MEDIUM';

            document.getElementById('threatLevel').textContent = threatText;
            document.getElementById('threatLevel').style.color = threatLevel >= 75 ? '#dc3545' : threatLevel >= 50 ? '#ffc107' : '#28a745';
            document.getElementById('threatFillBar').style.width = threatLevel + '%';

            // Calculate reaction time (simulated - based on detections)
            const baseReactionTime = 100;
            const detectionBonus = Math.min(totalDetections * 10, 50);
            const reactionTime = baseReactionTime - detectionBonus;
            document.getElementById('reactionTime').textContent = Math.max(50, reactionTime) + 'ms';

            // Detection accuracy (simulated)
            const accuracy = Math.min(95 + (vehicle.sensors.front.detectedObjects.length * 0.5), 99.9);
            document.getElementById('detectionAccuracy').textContent = accuracy.toFixed(1) + '%';

            // Update sensor range info
            document.getElementById('sensorRange').textContent = vehicle.detectionRadius + 'px';

            // Predictive Behavior
            let collisionRisk = 0;
            let pathObstruction = 'Clear';

            // Calculate collision risk based on front detections
            for (const detection of vehicle.sensors.front.detectedObjects) {
                if (detection.distanceLevel === 'CRITICAL') {
                    collisionRisk = Math.min(collisionRisk + 35, 100);
                } else if (detection.distanceLevel === 'WARNING') {
                    collisionRisk = Math.min(collisionRisk + 20, 100);
                } else if (detection.distanceLevel === 'MODERATE') {
                    collisionRisk = Math.min(collisionRisk + 8, 100);
                }
            }

            if (vehicle.sensors.front.detectedObjects.length > 0) {
                pathObstruction = 'Obstructed';
            }

            document.getElementById('collisionRisk').textContent = Math.round(collisionRisk) + '%';
            document.getElementById('pathObstruction').textContent = pathObstruction;

            // Safe distance calculation
            let minDist = Infinity;
            for (const detection of vehicle.sensors.front.detectedObjects) {
                minDist = Math.min(minDist, detection.distance);
            }
            document.getElementById('safeDistance').textContent = minDist === Infinity ? '--' : minDist.toFixed(0) + 'px';

            // Decision confidence (based on detection clarity)
            let confidence = 95;
            if (totalDetections > 5) confidence = Math.max(70, confidence - (totalDetections - 5) * 2);
            document.getElementById('decisionConfidence').textContent = Math.round(confidence) + '%';
        }

        function updateStats() {
            const allDetected = [
                ...vehicle.sensors.front.detectedObjects,
                ...vehicle.sensors.frontLeft.detectedObjects,
                ...vehicle.sensors.frontRight.detectedObjects,
                ...vehicle.sensors.left.detectedObjects,
                ...vehicle.sensors.right.detectedObjects,
                ...vehicle.sensors.back.detectedObjects
            ];

            const threatCount = allDetected.filter(d =>
                d.distanceLevel === 'CRITICAL' || d.distanceLevel === 'CLOSE'
            ).length;

            document.getElementById('objectCount').textContent = allDetected.length;
            document.getElementById('threatCount').textContent = threatCount;

            if (allDetected.length > 0) {
                const nearest = allDetected[0];
                const distStr = nearest.distance.toFixed(0) + 'px';
                document.getElementById('nearestDistance').textContent = distStr;
            } else {
                document.getElementById('nearestDistance').textContent = 'Safe';
            }

            const speedPercent = (vehicle.speed / vehicle.maxSpeed) * 100;
            document.getElementById('speedValue').textContent = Math.round(vehicle.speed * 10) + ' km/h';
            document.getElementById('speedFill').style.width = speedPercent + '%';
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw road with lanes
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw lane markings (horizontal)
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 10]);
            for (let i = 0; i < lanes.length - 1; i++) {
                ctx.beginPath();
                ctx.moveTo(0, (lanes[i].y + lanes[i + 1].y) / 2);
                ctx.lineTo(canvas.width, (lanes[i].y + lanes[i + 1].y) / 2);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Draw edge lines (horizontal)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, lanes[0].y - lanes[0].width / 2);
            ctx.lineTo(canvas.width, lanes[0].y - lanes[0].width / 2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, lanes[lanes.length - 1].y + lanes[lanes.length - 1].width / 2);
            ctx.lineTo(canvas.width, lanes[lanes.length - 1].y + lanes[lanes.length - 1].width / 2);
            ctx.stroke();

            // Update and draw objects
            for (let i = objects.length - 1; i >= 0; i--) {
                const shouldKeep = objects[i].update();
                if (!shouldKeep) {
                    objects.splice(i, 1);
                } else {
                    objects[i].draw(ctx);
                }
            }



            // Draw vehicle
            ctx.save();
            ctx.translate(vehicle.x, vehicle.y);

            // Handle crash animation for main vehicle
            if (vehicle.isCrashed) {
                const progress = vehicle.crashFrame / 80;
                const flicker = Math.sin(vehicle.crashFrame * 0.3) > 0 ? 0.5 : 1;
                ctx.fillStyle = `rgba(255, ${Math.floor(100 * flicker)}, 0, ${1 - progress * 0.5})`;
                const shrinkFactor = 1 - progress;
                ctx.fillRect(-vehicle.width / 2 * shrinkFactor, -vehicle.height / 2 * shrinkFactor, vehicle.width * shrinkFactor, vehicle.height * shrinkFactor);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-vehicle.width / 2 * shrinkFactor, -vehicle.height / 2 * shrinkFactor, vehicle.width * shrinkFactor, vehicle.height * shrinkFactor);

                // Draw explosion effect
                if (vehicle.crashFrame < 60) {
                    const numParticles = 8;
                    for (let i = 0; i < numParticles; i++) {
                        const angle = (i / numParticles) * Math.PI * 2;
                        const distance = (vehicle.crashFrame / 60) * 80;
                        const particleX = Math.cos(angle) * distance;
                        const particleY = Math.sin(angle) * distance;

                        ctx.fillStyle = `rgba(255, ${Math.floor(150 - vehicle.crashFrame)}, 0, ${1 - (vehicle.crashFrame / 60)})`;
                        ctx.beginPath();
                        const particleSize = 6 - (vehicle.crashFrame / 60) * 4;
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else {
                // Draw main vehicle image if available, otherwise draw default
                if (imageCache.mainVehicle) {
                    ctx.drawImage(imageCache.mainVehicle, -vehicle.width / 2, -vehicle.height / 2, vehicle.width, vehicle.height);
                } else {
                    // Fallback: default car drawing
                    const carColor = vehicle.emergencyBraking ? '#dc3545' : '#0066cc';

                    // Main body
                    ctx.fillStyle = carColor;
                    ctx.fillRect(-vehicle.width / 2, -vehicle.height / 2 + 4, vehicle.width, vehicle.height - 8);

                    // Cabin/Windows area (darker)
                    ctx.fillStyle = '#00ccff';
                    ctx.fillRect(-vehicle.width / 3, -vehicle.height / 2 + 8, vehicle.width * 0.66, vehicle.height / 2);

                    // Wheels
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(-vehicle.width / 3, vehicle.height / 2 - 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(vehicle.width / 3, vehicle.height / 2 - 2, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Headlights (bright)
                    ctx.fillStyle = '#ffff99';
                    ctx.beginPath();
                    ctx.arc(-vehicle.width / 4, -vehicle.height / 2 + 2, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(vehicle.width / 4, -vehicle.height / 2 + 2, 2.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Border
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-vehicle.width / 2, -vehicle.height / 2 + 4, vehicle.width, vehicle.height - 8);
                }
            }

            ctx.restore();

            // Draw sensor lines (if enabled)
            if (showSensors) {
                const sensorLength = 200;
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 2;

                // Front sensor (center)
                ctx.beginPath();
                ctx.moveTo(vehicle.x, vehicle.y);
                ctx.lineTo(vehicle.x + sensorLength, vehicle.y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(vehicle.x + sensorLength, vehicle.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Front-Left sensor
                ctx.strokeStyle = 'rgba(0, 255, 100, 0.5)';
                ctx.beginPath();
                ctx.moveTo(vehicle.x, vehicle.y);
                ctx.lineTo(vehicle.x + sensorLength * 0.9, vehicle.y - sensorLength * 0.5);
                ctx.stroke();
                ctx.fillStyle = 'rgba(0, 255, 100, 0.3)';
                ctx.beginPath();
                ctx.arc(vehicle.x + sensorLength * 0.9, vehicle.y - sensorLength * 0.5, 6, 0, Math.PI * 2);
                ctx.fill();

                // Front-Right sensor
                ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
                ctx.beginPath();
                ctx.moveTo(vehicle.x, vehicle.y);
                ctx.lineTo(vehicle.x + sensorLength * 0.9, vehicle.y + sensorLength * 0.5);
                ctx.stroke();
                ctx.fillStyle = 'rgba(0, 200, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(vehicle.x + sensorLength * 0.9, vehicle.y + sensorLength * 0.5, 6, 0, Math.PI * 2);
                ctx.fill();

                // Left sensor
                ctx.strokeStyle = 'rgba(100, 255, 200, 0.5)';
                ctx.beginPath();
                ctx.moveTo(vehicle.x, vehicle.y);
                ctx.lineTo(vehicle.x - sensorLength * 0.3, vehicle.y - sensorLength * 0.8);
                ctx.stroke();
                ctx.fillStyle = 'rgba(100, 255, 200, 0.3)';
                ctx.beginPath();
                ctx.arc(vehicle.x - sensorLength * 0.3, vehicle.y - sensorLength * 0.8, 6, 0, Math.PI * 2);
                ctx.fill();

                // Right sensor
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
                ctx.beginPath();
                ctx.moveTo(vehicle.x, vehicle.y);
                ctx.lineTo(vehicle.x - sensorLength * 0.3, vehicle.y + sensorLength * 0.8);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 200, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(vehicle.x - sensorLength * 0.3, vehicle.y + sensorLength * 0.8, 6, 0, Math.PI * 2);
                ctx.fill();

                // Back sensor
                ctx.strokeStyle = 'rgba(200, 0, 200, 0.5)';
                ctx.beginPath();
                ctx.moveTo(vehicle.x, vehicle.y);
                ctx.lineTo(vehicle.x - sensorLength, vehicle.y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(200, 0, 200, 0.3)';
                ctx.beginPath();
                ctx.arc(vehicle.x - sensorLength, vehicle.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            if (isRunning) {
                frameCount++;

                // Auto-spawn vehicles (only after car reaches halfway through lane)
                 if (vehicle.x > canvas.width / 2 && frameCount - lastAutoSpawnFrame > autoSpawnInterval) {
                     const randomType = autoSpawnTypes[Math.floor(Math.random() * autoSpawnTypes.length)];
                     let randomLane;
                     
                     // If car is at start of lane, spawn in different lanes
                     if (vehicle.x < 200) {
                         // Spawn in a different lane than the car
                         do {
                             randomLane = Math.floor(Math.random() * lanes.length);
                         } while (randomLane === vehicle.currentLane);
                     } else {
                         // Car is past start, can spawn in any lane
                         randomLane = Math.floor(Math.random() * lanes.length);
                     }
                     
                     objects.push(new DrivingObject(randomType, -50, lanes[randomLane].y, 4, randomLane));
                     lastAutoSpawnFrame = frameCount;
                 }

                detectObjects();
                checkPersonVehicleCollisions();
                checkVehicleCollisions();
                updateVehicleControl();
                updateActionLog();
                updateStats();
                updateAdvancedAIMetrics();
            }

            requestAnimationFrame(animate);
        }

        // Click to spawn or delete
        // Check if position collides with existing vehicles
        function canPlaceVehicle(x, y, width, height) {
            // Check collision with main vehicle
            const dx = x - vehicle.x;
            const dy = y - vehicle.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = (width + vehicle.width) / 2;
            if (dist < minDist) {
                return false;
            }
            
            // Check collision with other vehicles
            for (let i = 0; i < objects.length; i++) {
                const obj = objects[i];
                if (['car', 'bus', 'truck'].includes(obj.type)) {
                    const dx = x - obj.x;
                    const dy = y - obj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (width + obj.width) / 2;
                    if (dist < minDist) {
                        return false;
                    }
                }
            }
            return true;
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (deleteMode) {
                // Delete object at click location
                for (let i = objects.length - 1; i >= 0; i--) {
                    const obj = objects[i];
                    const dx = obj.x - x;
                    const dy = obj.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < obj.width) {
                        objects.splice(i, 1);
                        break;
                    }
                }
                return;
            }

            if (!spawnMode) return;

            if (['car', 'bus', 'truck'].includes(spawnMode)) {
                // Find closest lane
                let closestLane = 0;
                let minDist = Math.abs(y - lanes[0].y);
                for (let i = 1; i < lanes.length; i++) {
                    const dist = Math.abs(y - lanes[i].y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestLane = i;
                    }
                }
                // Check if vehicle can be placed without collision
                const testVehicle = spawnMode === 'car' ? { width: 60, height: 35 } : spawnMode === 'bus' ? { width: 100, height: 45 } : { width: 90, height: 50 };
                if (canPlaceVehicle(x, lanes[closestLane].y, testVehicle.width, testVehicle.height)) {
                    objects.push(new DrivingObject(spawnMode, x, lanes[closestLane].y, 4, closestLane));
                } else {
                    alert('Cannot place vehicle here - it would overlap with another vehicle!');
                    return;
                }
            } else if (['cone', 'barrier', 'pothole'].includes(spawnMode)) {
                // These obstacles can go in lanes too
                let closestLane = 0;
                let minDist = Math.abs(y - lanes[0].y);
                for (let i = 1; i < lanes.length; i++) {
                    const dist = Math.abs(y - lanes[i].y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestLane = i;
                    }
                }
                objects.push(new DrivingObject(spawnMode, x, lanes[closestLane].y, 0, closestLane));
            } else if (spawnMode === 'custom_person') {
                // Handle custom person with name and color
                const nameInput = document.getElementById('personName');
                const colorInput = document.getElementById('personColor');
                const person = new DrivingObject('person', x, y, 2);
                person.name = nameInput.value || 'Person';
                person.color = colorInput.value;
                objects.push(person);
            } else {
                objects.push(new DrivingObject(spawnMode, x, y, spawnMode === 'person' ? 2 : 0));
            }

            spawnMode = null;
            document.getElementById('spawnHint').style.display = 'none';
            document.querySelectorAll('button').forEach(btn => btn.classList.remove('spawn-mode'));
        });

        // Button handlers
        function makeSpawnButton(btnId, type) {
            document.getElementById(btnId).addEventListener('click', function () {
                spawnMode = spawnMode === type ? null : type;
                this.classList.toggle('spawn-mode');
                const hint = document.getElementById('spawnHint');
                hint.style.display = spawnMode ? 'block' : 'none';
            });
        }

        makeSpawnButton('spawnCar', 'car');

        // Custom person spawner
        document.getElementById('spawnPerson').addEventListener('click', function () {
            const customizer = document.getElementById('personCustomizer');
            const isActive = spawnMode === 'custom_person';
            spawnMode = isActive ? null : 'custom_person';
            this.classList.toggle('spawn-mode');
            customizer.style.display = spawnMode === 'custom_person' ? 'flex' : 'none';
            const hint = document.getElementById('spawnHint');
            hint.style.display = spawnMode ? 'block' : 'none';
            if (spawnMode) {
                hint.textContent = 'Click on canvas to place person';
            }
        });
        makeSpawnButton('spawnBus', 'bus');
        makeSpawnButton('spawnTruck', 'truck');
        makeSpawnButton('spawnStopSign', 'stop sign');
        makeSpawnButton('spawnTrafficLight', 'traffic light');
        makeSpawnButton('spawnYield', 'yield');
        makeSpawnButton('spawnBuilding', 'building');
        makeSpawnButton('spawnTree', 'tree');
        makeSpawnButton('spawnPole', 'pole');
        makeSpawnButton('spawnCone', 'cone');
        makeSpawnButton('spawnBarrier', 'barrier');
        makeSpawnButton('spawnPothole', 'pothole');

        // Traffic jam spawn
        document.getElementById('spawnTrafficJam').addEventListener('click', () => {
            const jamLane = Math.floor(Math.random() * lanes.length);
            for (let i = 0; i < 5; i++) {
                const randomType = autoSpawnTypes[Math.floor(Math.random() * autoSpawnTypes.length)];
                // Spawn vehicles on screen, spaced 80 pixels apart
                objects.push(new DrivingObject(randomType, 150 + (i * 80), lanes[jamLane].y, 0.5, jamLane));
            }
        });

        // Group people spawn
        document.getElementById('spawnGroupPeople').addEventListener('click', () => {
            for (let i = 0; i < 6; i++) {
                const x = 200 + Math.random() * (canvas.width - 400);
                const y = 100 + Math.random() * (canvas.height - 200);
                objects.push(new DrivingObject('person', x, y, 0));
            }
        });



        document.getElementById('startStop').addEventListener('click', function () {
            isRunning = !isRunning;
            this.textContent = isRunning ? 'Stop' : 'Start';
            this.style.background = isRunning ? '#ff9500' : '#0066cc';
        });

        document.getElementById('deleteMode').addEventListener('click', function () {
            deleteMode = !deleteMode;
            spawnMode = null;
            this.classList.toggle('delete-mode');
            document.querySelectorAll('button').forEach(btn => btn.classList.remove('spawn-mode'));
            const hint = document.getElementById('spawnHint');
            hint.style.display = deleteMode ? 'block' : 'none';
            hint.textContent = deleteMode ? 'Click on object to delete (except self-driving car)' : 'Click on canvas to place object';
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            objects.length = 0;
            vehicle.speed = 0;
            vehicle.isStopped = false;
            vehicle.emergencyBraking = false;
            vehicle.x = 100;
            document.getElementById('actionLog').innerHTML = '<li class="info">âœ“ Scene cleared</li>';
        });

        document.getElementById('toggleSensors').addEventListener('click', function () {
            showSensors = !showSensors;
            this.textContent = showSensors ? 'Sensors ON' : 'Sensors OFF';
            this.style.background = showSensors ? '#0066cc' : '#6c757d';
            this.style.color = showSensors ? '#000' : '#fff';
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            restartVehicle();
        });

        // Traffic light color control
        document.getElementById('lightRed').addEventListener('click', () => {
            selectedTrafficLightColor = '#ff0000';
            updateTrafficLightButtons();
        });
        document.getElementById('lightYellow').addEventListener('click', () => {
            selectedTrafficLightColor = '#ffaa00';
            updateTrafficLightButtons();
        });
        document.getElementById('lightGreen').addEventListener('click', () => {
            selectedTrafficLightColor = '#28a745';
            updateTrafficLightButtons();
        });

        function updateTrafficLightButtons() {
            document.getElementById('lightRed').style.border = selectedTrafficLightColor === '#ff0000' ? '3px solid #fff' : '2px solid #666';
            document.getElementById('lightYellow').style.border = selectedTrafficLightColor === '#ffaa00' ? '3px solid #fff' : '2px solid #666';
            document.getElementById('lightGreen').style.border = selectedTrafficLightColor === '#00ff00' ? '3px solid #fff' : '2px solid #666';
        }

        // Start animation
        animate();
    </script>


</body>

</html>
