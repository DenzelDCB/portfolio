<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Vehicle Simulator - AI Based</title>
    <style>
        :root {
            --bg-primary: #001f3f;      /* Deep navy blue for dark theme */
            --bg-secondary: #112d4e;    /* Darker blue panels */
            --accent: #007bff;          /* Bootstrap-like blue */
            --accent-light: #339aff;
            --accent-dark: #0056b3;
            --text-primary: #e0f7ff;    /* Light cyan */
            --text-muted: #a0d8ff;
            --border: #339aff;
            --road: #2c3e50;
            --lane-line: #5dade2;
        }

        @media (prefers-color-scheme: light) {
            :root {
                --bg-primary: #f0f8ff;      /* Alice blue - very light */
                --bg-secondary: #d0e8ff;   /* Light blue panel */
                --accent: #007bff;
                --accent-light: #339aff;
                --accent-dark: #0056b3;
                --text-primary: #001f3f;    /* Dark navy text */
                --text-muted: #004080;
                --border: #007bff;
                --road: #ecf0f1;
                --lane-line: #3498db;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            padding: 15px;
            gap: 15px;
        }

        .canvas-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .title {
            text-align: center;
            font-size: 1.6rem;
            font-weight: 600;
            color: var(--accent-light);
            letter-spacing: 1px;
        }

        canvas {
            background: linear-gradient(to bottom, #87cefa 0%, #e0f6ff 70%, #c0e8d0 100%);
            border: 4px solid var(--accent);
            border-radius: 10px;
            flex: 1;
            cursor: crosshair;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        @media (prefers-color-scheme: light) {
            canvas {
                background: linear-gradient(to bottom, #87cefa 0%, #e0f6ff 70%, #c0e8d0 100%);
            }
        }

        .controls {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 160px;
        }

        .control-group label {
            font-size: 0.9rem;
            color: var(--text-muted);
            font-weight: 500;
        }

        .button-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        button:hover {
            background: var(--accent-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        button.active, button.spawn-mode {
            background: var(--accent-dark);
            transform: scale(1.05);
        }

        button.delete-mode {
            background: #dc3545;
        }

        button.delete-mode:hover {
            background: #c82333;
        }

        #personCustomizer {
            display: none;
            gap: 8px;
            align-items: center;
            margin-top: 6px;
        }

        #personCustomizer input[type="text"] {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 100px;
        }

        #personCustomizer input[type="color"] {
            width: 40px;
            height: 36px;
            cursor: pointer;
            border: 2px solid var(--border);
            border-radius: 4px;
        }

        .spawn-hint {
            text-align: center;
            padding: 8px;
            background: var(--accent);
            color: white;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.95rem;
        }

        .output-section {
            flex: 1;
            min-width: 360px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .panel {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .panel h3 {
            color: var(--accent-light);
            margin-bottom: 10px;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 6px;
        }

        .action-log {
            list-style: none;
            flex: 1;
            overflow-y: auto;
            font-size: 0.85rem;
        }

        .action-log li {
            padding: 6px 8px;
            margin: 4px 0;
            border-left: 3px solid var(--accent);
            background: rgba(0,123,255,0.1);
            border-radius: 4px;
        }

        .action-log li.critical { border-left-color: #dc3545; background: rgba(220,53,69,0.15); }
        .action-log li.warning  { border-left-color: #ffc107; background: rgba(255,193,7,0.15); }
        .action-log li.info     { border-left-color: #28a745; background: rgba(40,167,69,0.1); }

        .stats {
            font-size: 0.9rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px dashed var(--border);
        }

        .stat-row:last-child { border: none; }

        .speed-indicator {
            height: 12px;
            background: #1a3a5a;
            border-radius: 6px;
            overflow: hidden;
            margin: 8px 0;
        }

        .speed-fill {
            height: 100%;
            background: linear-gradient(to right, #007bff, #00c3ff);
            width: 0%;
            transition: width 0.4s ease;
        }

        .traffic-light-control .light-buttons {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 10px;
        }

        .light-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #444;
            cursor: pointer;
            transition: all 0.2s;
        }

        .light-btn.red    { background: #dc3545; }
        .light-btn.yellow { background: #ffc107; }
        .light-btn.green  { background: #28a745; }

        .light-btn:hover { transform: scale(1.15); border-color: white; }

        .light-btn.active { border: 4px solid white; box-shadow: 0 0 15px rgba(255,255,255,0.6); }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-light);
        }

        .crash-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
        }

        .crash-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            border: 4px solid var(--accent);
            padding: 40px 60px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(0, 123, 255, 0.6);
        }

        .crash-modal h2 {
            font-size: 3rem;
            color: #dc3545;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #dc3545;
        }

        .crash-modal button {
            background: var(--accent);
            font-size: 1.2rem;
            padding: 14px 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-section">
            <div class="title">AUTONOMOUS VEHICLE SIMULATOR<br><small>AI-Powered Lane Detection & Decision Making</small></div>
            <canvas id="canvas"></canvas>

            <div class="controls">
                <div class="control-group">
                    <label>Vehicles (Lane-based)</label>
                    <div class="button-row">
                        <button id="spawnCar">Car</button>
                        <button id="spawnBus">Bus</button>
                        <button id="spawnTruck">Truck</button>
                        <button id="spawnTrafficJam">Traffic Jam</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Pedestrians (Free Placement)</label>
                    <div class="button-row">
                        <button id="spawnPerson">Custom Person</button>
                        <button id="spawnGroupPeople">Group (6)</button>
                    </div>
                    <div id="personCustomizer">
                        <input type="text" id="personName" placeholder="Name (optional)" maxlength="15">
                        <input type="color" id="personColor" value="#ff99ff">
                    </div>
                </div>

                <div class="control-group">
                    <label>Traffic Signs</label>
                    <div class="button-row">
                        <button id="spawnStopSign">Stop Sign</button>
                        <button id="spawnTrafficLight">Traffic Light</button>
                        <button id="spawnYield">Yield</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Obstacles</label>
                    <div class="button-row">
                        <button id="spawnBuilding">Building</button>
                        <button id="spawnTree">Tree</button>
                        <button id="spawnPole">Pole</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Simulation Control</label>
                    <div class="button-row">
                        <button id="startStop">Start</button>
                        <button id="deleteMode">Delete Mode</button>
                        <button id="clearAll">Clear All</button>
                        <button id="toggleSensors" class="active">Sensors ON</button>
                    </div>
                </div>
            </div>

            <div id="spawnHint" class="spawn-hint" style="display:none;">Click on the canvas to place the selected object</div>
        </div>

        <div class="output-section">
            <div class="panel">
                <h3>Real-Time AI Decisions</h3>
                <ul class="action-log" id="actionLog"></ul>
            </div>

            <div class="panel stats">
                <h3>Vehicle Status</h3>
                <div class="stat-row"><span>Speed:</span><span id="speedValue">0 km/h</span></div>
                <div class="speed-indicator"><div class="speed-fill" id="speedFill"></div></div>
                <div class="stat-row"><span>Objects Detected:</span><span id="objectCount">0</span></div>
                <div class="stat-row"><span>Critical Threats:</span><span id="threatCount">0</span></div>
                <div class="stat-row"><span>Nearest Object:</span><span id="nearestDistance">Safe</span></div>
                <div class="stat-row"><span>AI Status:</span><span id="status">Idle</span></div>
            </div>

            <div class="panel traffic-light-control">
                <h3>Manual Traffic Light Control</h3>
                <div class="light-buttons">
                    <div class="light-btn red" id="lightRed" title="Red"></div>
                    <div class="light-btn yellow" id="lightYellow" title="Yellow"></div>
                    <div class="light-btn green" id="lightGreen" title="Green"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="crash-overlay" id="crashOverlay"></div>
    <div class="crash-modal" id="crashModal">
        <h2>CRASHED</h2>
        <button id="restartBtn">RESET SIMULATION</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight - 140; // account for title + controls + hint
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const lanes = [
            { y: canvas.height * 0.35, width: 80 },
            { y: canvas.height * 0.5,  width: 80 },
            { y: canvas.height * 0.65, width: 80 }
        ];

        const vehicle = {
            x: 100,
            y: canvas.height * 0.5,
            width: 50,
            height: 30,
            speed: 0,
            maxSpeed: 8,
            direction: 0,
            detectionRadius: 250,
            isStopped: false,
            actionQueue: [],
            emergencyBraking: false,
            currentLane: 1,
            laneChangeTime: 0,
            lastLaneChangeFrame: 0,
            laneChangeCooldown: 30,
            isCrashed: false,
            crashFrame: 0,
            sensors: {
                front: { detectedObjects: [] },
                frontLeft: { detectedObjects: [] },
                frontRight: { detectedObjects: [] },
                left: { detectedObjects: [] },
                right: { detectedObjects: [] },
                back: { detectedObjects: [] }
            }
        };

        let isRunning = false;
        let spawnMode = null;
        let deleteMode = false;
        const objects = [];
        let nextId = 0;
        let selectedTrafficLightColor = '#00ff00';
        let frameCount = 0;
        let showSensors = true;
        let lastAutoSpawnFrame = 0;
        const autoSpawnInterval = 120;
        const autoSpawnTypes = ['car', 'bus', 'truck'];

        class DrivingObject {
            constructor(type, x, y, speed = 0, laneIndex = null) {
                this.id = nextId++;
                this.type = type;
                this.x = x;
                this.y = y;
                this.speed = speed;
                this.direction = 0;
                this.targetX = x;
                this.targetY = y;
                this.laneIndex = laneIndex;
                this.isHit = false;
                this.hitFrame = 0;
                this.originalWidth = null;
                this.originalHeight = null;
                this.isCrashed = false;
                this.crashFrame = 0;
                this.crashParticles = [];
                this.name = null;

                switch (type) {
                    case 'car':
                        this.width = 25; this.height = 40; this.color = '#ff0000'; this.maxSpeed = 6; break;
                    case 'person':
                        this.width = 12; this.height = 30; this.color = '#ff99ff'; this.maxSpeed = 3; break;
                    case 'bus':
                        this.width = 30; this.height = 50; this.color = '#ffff00'; this.maxSpeed = 5; break;
                    case 'truck':
                        this.width = 35; this.height = 55; this.color = '#ff6600'; this.maxSpeed = 4; break;
                    case 'building':
                        this.width = 60; this.height = 70; this.color = '#8b4513'; this.maxSpeed = 0; break;
                    case 'tree':
                        this.width = 20; this.height = 50; this.color = '#228b22'; this.maxSpeed = 0; break;
                    case 'pole':
                        this.width = 8; this.height = 60; this.color = '#a9a9a9'; this.maxSpeed = 0; break;
                    case 'stop sign':
                        this.width = 25; this.height = 25; this.color = '#ff0000'; this.maxSpeed = 0; this.shape = 'octagon'; break;
                    case 'yield':
                        this.width = 20; this.height = 20; this.color = '#ff6600'; this.maxSpeed = 0; this.shape = 'triangle'; break;
                    case 'traffic light':
                        this.width = 15; this.height = 40; this.color = '#00ff00'; this.lightColor = '#00ff00'; this.maxSpeed = 0; break;
                }
                this.originalWidth = this.width;
                this.originalHeight = this.height;
            }

            update() {
                if (!isRunning) return true;

                if (this.isCrashed) {
                    this.crashFrame++;
                    if (this.crashFrame > 80) return false;
                    const progress = this.crashFrame / 80;
                    this.width = this.originalWidth * (1 - progress);
                    this.height = this.originalHeight * (1 - progress);
                    return true;
                }

                if (this.isHit) {
                    this.hitFrame++;
                    if (this.hitFrame > 60) return false;
                    const progress = this.hitFrame / 60;
                    this.width = this.originalWidth * (1 - progress);
                    this.height = this.originalHeight * (1 - progress);
                    return true;
                }

                if (['car', 'bus', 'truck'].includes(this.type) && this.laneIndex !== null) {
                    this.y = lanes[this.laneIndex].y;

                    let shouldStop = false;
                    let shouldSlow = false;
                    const detectionDist = 200;

                    for (const obj of objects) {
                        if (obj.type === 'stop sign') {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -detectionDist && Math.abs(this.y - obj.y) < 100) shouldStop = true;
                        }
                        if (obj.type === 'traffic light') {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -detectionDist && Math.abs(this.y - obj.y) < 100) {
                                if (obj.lightColor === '#ff0000') shouldStop = true;
                                else if (obj.lightColor === '#ffaa00') shouldSlow = true;
                            }
                        }
                        if (obj.type === 'yield') {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -detectionDist && Math.abs(this.y - obj.y) < 100) shouldSlow = true;
                        }
                        if (['building', 'tree', 'pole'].includes(obj.type)) {
                            const dx = this.x - obj.x;
                            const dy = this.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < this.width + obj.width + 100 && dx < 0) {
                                if (dist < this.width + obj.width + 20) shouldStop = true;
                                else shouldSlow = true;
                            }
                        }
                    }

                    for (const obj of objects) {
                        if (obj.id === this.id) continue;
                        if (['car', 'bus', 'truck'].includes(obj.type) && obj.laneIndex === this.laneIndex) {
                            const dist = this.x - obj.x;
                            if (dist < 0 && dist > -150) {
                                if (Math.abs(dist) < 60) shouldStop = true;
                                else shouldSlow = true;
                            }
                        }
                    }

                    if (vehicle.currentLane === this.laneIndex) {
                        const dist = this.x - vehicle.x;
                        if (dist < 0 && dist > -150) {
                            if (Math.abs(dist) < 80) shouldStop = true;
                            else shouldSlow = true;
                        }
                    }

                    if (shouldStop) this.speed = 0;
                    else if (shouldSlow) this.speed = Math.max(0, Math.min(this.speed - 0.3, this.maxSpeed * 0.3));
                    else this.speed = Math.min(this.speed + 0.2, this.maxSpeed);

                    this.x += this.speed;
                    if (this.x > canvas.width + this.width) return false;
                } else if (this.type === 'person') {
                    if (Math.random() < 0.03) {
                        this.targetX = Math.random() * canvas.width;
                        this.targetY = Math.random() * canvas.height;
                    }

                    let avoidX = 0, avoidY = 0;
                    const avoidRadius = 150;

                    const vDx = this.x - vehicle.x;
                    const vDy = this.y - vehicle.y;
                    const vDist = Math.sqrt(vDx * vDx + vDy * vDy);
                    if (vDist < avoidRadius && vDist > 0) {
                        avoidX += (vDx / vDist) * (1 - vDist / avoidRadius);
                        avoidY += (vDy / vDist) * (1 - vDist / avoidRadius);
                    }

                    for (const obj of objects) {
                        if (obj.id === this.id) continue;
                        if (['car', 'bus', 'truck', 'building', 'tree', 'pole'].includes(obj.type)) {
                            const dx = this.x - obj.x;
                            const dy = this.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < avoidRadius && dist > 0) {
                                avoidX += (dx / dist) * (1 - dist / avoidRadius);
                                avoidY += (dy / dist) * (1 - dist / avoidRadius);
                            }
                        }
                    }

                    const dx = this.targetX - this.x + avoidX * 100;
                    const dy = this.targetY - this.y + avoidY * 100;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5) {
                        this.speed = Math.min(this.speed + 0.1, this.maxSpeed);
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                    } else {
                        this.speed = 0;
                    }

                    this.x = Math.max(this.width / 2, Math.min(canvas.width - this.width / 2, this.x));
                    this.y = Math.max(this.height / 2, Math.min(canvas.height - this.height / 2, this.y));
                } else if (this.type === 'traffic light') {
                    this.lightColor = selectedTrafficLightColor;
                }

                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                let drawColor = this.color;
                if (this.isCrashed) {
                    const flicker = Math.sin(this.crashFrame * 0.3) > 0 ? 0.5 : 1;
                    drawColor = `rgba(255, ${Math.floor(100 * flicker)}, 0, ${1 - (this.crashFrame / 80) * 0.5})`;
                } else if (this.isHit) {
                    drawColor = '#999999';
                }

                if (this.shape === 'octagon') {
                    drawOctagon(ctx, this.width / 2, drawColor);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('STOP', 0, 0);
                } else if (this.shape === 'triangle') {
                    drawTriangle(ctx, this.width / 2, drawColor);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('YIELD', 0, 3);
                } else if (this.type === 'traffic light') {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.fillStyle = this.lightColor === '#ff0000' ? '#ff0000' : '#333';
                    ctx.beginPath(); ctx.arc(0, -10, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = this.lightColor === '#ffaa00' ? '#ffaa00' : '#333';
                    ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = this.lightColor === '#00ff00' ? '#00ff00' : '#333';
                    ctx.beginPath(); ctx.arc(0, 10, 4, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillStyle = drawColor;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                }

                if (this.name && this.type === 'person') {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(this.name, 0, -this.height / 2 - 5);
                }

                ctx.restore();
            }

            getDistance(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            getArea() {
                return this.width * this.height;
            }
        }

        function drawOctagon(ctx, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawTriangle(ctx, radius, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, -radius);
            ctx.lineTo(radius, radius);
            ctx.lineTo(-radius, radius);
            ctx.closePath();
            ctx.fill();
        }

        function detectObjects() {
            vehicle.sensors.front.detectedObjects = [];
            vehicle.sensors.frontLeft.detectedObjects = [];
            vehicle.sensors.frontRight.detectedObjects = [];
            vehicle.sensors.left.detectedObjects = [];
            vehicle.sensors.right.detectedObjects = [];
            vehicle.sensors.back.detectedObjects = [];

            const imageArea = canvas.width * canvas.height;

            for (const obj of objects) {
                const dx = obj.x - vehicle.x;
                const dy = obj.y - vehicle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > vehicle.detectionRadius) continue;

                const area = obj.getArea();
                const occupancy = (area / imageArea) * 100;

                let distanceLevel = 'SAFE';
                if (dist < 60) distanceLevel = 'CRITICAL';
                else if (dist < 100) distanceLevel = 'WARNING';
                else if (dist < 150) distanceLevel = 'MODERATE';
                else if (dist < 200) distanceLevel = 'OKAY';

                const detection = { obj, distance: dist, distanceLevel, occupancy };

                if (dx > 20) {
                    if (Math.abs(dy) < 50) vehicle.sensors.front.detectedObjects.push(detection);
                    else if (dy < -50) vehicle.sensors.frontLeft.detectedObjects.push(detection);
                    else if (dy > 50) vehicle.sensors.frontRight.detectedObjects.push(detection);
                } else if (dx < -20) {
                    vehicle.sensors.back.detectedObjects.push(detection);
                } else {
                    dy < 0 ? vehicle.sensors.left.detectedObjects.push(detection) : vehicle.sensors.right.detectedObjects.push(detection);
                }
            }
        }

        function getAction() {
            const actions = [];
            let threatLevel = 'safe';
            let blockingFront = false;
            let redLightBlocking = false;

            for (const detection of vehicle.sensors.front.detectedObjects) {
                const obj = detection.obj;
                const distanceLevel = detection.distanceLevel;

                if (['car', 'bus', 'truck'].includes(obj.type)) {
                    if (distanceLevel === 'CRITICAL') { threatLevel = 'critical'; blockingFront = true; actions.push({type:'CRITICAL', text:`âš  EMERGENCY - ${obj.type.toUpperCase()} AHEAD - BRAKE`, priority:1}); }
                    else if (distanceLevel === 'WARNING') { if(threatLevel!=='critical')threatLevel='warning'; blockingFront=true; actions.push({type:'WARNING', text:`âš  DANGER - ${obj.type.toUpperCase()} AHEAD`, priority:2}); }
                } else if (obj.type === 'person') {
                    if (distanceLevel === 'CRITICAL') { threatLevel = 'critical'; blockingFront = true; actions.push({type:'CRITICAL', text:'ðŸš¨ PEDESTRIAN CRITICAL - BRAKE', priority:1}); }
                } else if (['building','tree','pole'].includes(obj.type)) {
                    if (distanceLevel === 'CRITICAL' || distanceLevel === 'WARNING') { threatLevel = 'warning'; blockingFront = true; actions.push({type:'CRITICAL', text:`âš  OBSTACLE COLLISION RISK`, priority:1}); }
                } else if (obj.type === 'stop sign') {
                    if (distanceLevel === 'CRITICAL' || distanceLevel === 'WARNING') { threatLevel = 'warning'; blockingFront = true; actions.push({type:'CRITICAL', text:'ðŸ›‘ STOP SIGN - HALT', priority:1}); }
                } else if (obj.type === 'traffic light') {
                    if (obj.lightColor === '#ff0000') { threatLevel = 'warning'; blockingFront = true; redLightBlocking = true; actions.push({type:'CRITICAL', text:'ðŸ”´ RED LIGHT - STOP', priority:1}); }
                    else if (obj.lightColor === '#ffaa00') { actions.push({type:'WARNING', text:'ðŸŸ¡ YELLOW - SLOW DOWN', priority:2}); }
                    else actions.push({type:'INFO', text:'ðŸŸ¢ GREEN - PROCEED', priority:3});
                } else if (obj.type === 'yield') {
                    if (distanceLevel === 'CRITICAL' || distanceLevel === 'WARNING') { actions.push({type:'WARNING', text:'ðŸš§ YIELD REQUIRED', priority:2}); }
                }
            }

            const sideBlockFrontLeft = vehicle.sensors.frontLeft.detectedObjects.some(d => ['car','bus','truck','person'].includes(d.obj.type) && ['CRITICAL','WARNING','MODERATE'].includes(d.distanceLevel));
            const sideBlockFrontRight = vehicle.sensors.frontRight.detectedObjects.some(d => ['car','bus','truck','person'].includes(d.obj.type) && ['CRITICAL','WARNING','MODERATE'].includes(d.distanceLevel));

            return { actions: actions.sort((a,b)=>a.priority-b.priority), threatLevel, blockingFront, sideBlockFrontLeft, sideBlockFrontRight, redLightBlocking };
        }

        function updateVehicleControl() {
            if (vehicle.isCrashed) { vehicle.crashFrame++; return; }

            const { actions, threatLevel, blockingFront, sideBlockFrontLeft, sideBlockFrontRight, redLightBlocking } = getAction();
            vehicle.actionQueue = actions;

            if (threatLevel === 'critical') {
                vehicle.emergencyBraking = true;
                vehicle.speed = 0;
                vehicle.isStopped = true;
                document.getElementById('status').textContent = 'EMERGENCY STOP';
            } else if (threatLevel === 'warning') {
                vehicle.speed = Math.max(0, vehicle.speed - 0.5);
                document.getElementById('status').textContent = 'SLOWING DOWN';
            } else {
                vehicle.emergencyBraking = false;
                vehicle.speed = Math.min(vehicle.speed + 0.1, vehicle.maxSpeed);
                document.getElementById('status').textContent = threatLevel === 'caution' ? 'CAUTIOUS' : 'NORMAL';
            }

            if (blockingFront && !redLightBlocking && vehicle.speed > 0 && frameCount - vehicle.lastLaneChangeFrame > vehicle.laneChangeCooldown) {
                let laneChanged = false;
                if (vehicle.currentLane === 1) {
                    if (!sideBlockFrontLeft) { vehicle.currentLane = 0; laneChanged = true; }
                    else if (!sideBlockFrontRight) { vehicle.currentLane = 2; laneChanged = true; }
                } else if (vehicle.currentLane === 0 && !sideBlockFrontLeft) { vehicle.currentLane = 1; laneChanged = true; }
                else if (vehicle.currentLane === 2 && !sideBlockFrontRight) { vehicle.currentLane = 1; laneChanged = true; }

                if (laneChanged) vehicle.lastLaneChangeFrame = frameCount;
            }

            vehicle.y = lanes[vehicle.currentLane].y;
            vehicle.x += vehicle.speed;
            if (vehicle.x > canvas.width) {
                vehicle.x = 0;
                objects.length = 0;
            }
        }

        function checkPersonVehicleCollisions() {
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                if (obj.type === 'person' && !obj.isHit) {
                    const dx = obj.x - vehicle.x;
                    const dy = obj.y - vehicle.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < (obj.width + vehicle.width)/2) obj.isHit = obj.hitFrame = true;
                }
            }
        }

        function checkVehicleCollisions() {
            for (let i = 0; i < objects.length; i++) {
                const obj1 = objects[i];
                if (!['car','bus','truck'].includes(obj1.type) || obj1.isCrashed) continue;

                if (!vehicle.isCrashed) {
                    const dx = obj1.x - vehicle.x;
                    const dy = obj1.y - vehicle.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < (obj1.width + vehicle.width)/2) {
                        obj1.isCrashed = vehicle.isCrashed = true;
                        obj1.crashFrame = vehicle.crashFrame = 0;
                        showCrashModal();
                    }
                }
            }
        }

        function showCrashModal() {
            document.getElementById('crashOverlay').style.display = 'block';
            document.getElementById('crashModal').style.display = 'block';
            isRunning = false;
            document.getElementById('startStop').textContent = 'Start';
        }

        function restartVehicle() {
            document.getElementById('crashOverlay').style.display = 'none';
            document.getElementById('crashModal').style.display = 'none';
            vehicle.x = 100;
            vehicle.y = lanes[1].y;
            vehicle.speed = 0;
            vehicle.isCrashed = false;
            vehicle.currentLane = 1;
            vehicle.actionQueue = [];
            vehicle.sensors = { front:{}, frontLeft:{}, frontRight:{}, left:{}, right:{}, back:{} };
            Object.keys(vehicle.sensors).forEach(k => vehicle.sensors[k].detectedObjects = []);
        }

        function updateActionLog() {
            const log = document.getElementById('actionLog');
            log.innerHTML = '';
            if (vehicle.actionQueue.length === 0) {
                const li = document.createElement('li');
                li.className = 'info';
                li.textContent = 'âœ“ All clear - Safe to proceed';
                log.appendChild(li);
            } else {
                vehicle.actionQueue.slice(0,6).forEach(action => {
                    const li = document.createElement('li');
                    li.className = action.type.toLowerCase();
                    li.textContent = action.text;
                    log.appendChild(li);
                });
            }
        }

        function updateStats() {
            const allDetected = Object.values(vehicle.sensors).reduce((a,s)=>a.concat(s.detectedObjects||[]), []);
            const threatCount = allDetected.filter(d => ['CRITICAL'].includes(d.distanceLevel)).length;
            document.getElementById('objectCount').textContent = allDetected.length;
            document.getElementById('threatCount').textContent = threatCount;
            document.getElementById('nearestDistance').textContent = allDetected.length ? allDetected.sort((a,b)=>a.distance-b.distance)[0].distance.toFixed(0)+'px' : 'Safe';
            const speedPercent = (vehicle.speed / vehicle.maxSpeed) * 100;
            document.getElementById('speedValue').textContent = Math.round(vehicle.speed * 10) + ' km/h';
            document.getElementById('speedFill').style.width = speedPercent + '%';
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 10]);
            for (let i = 0; i < lanes.length - 1; i++) {
                const midY = (lanes[i].y + lanes[i + 1].y) / 2;
                ctx.beginPath();
                ctx.moveTo(0, midY);
                ctx.lineTo(canvas.width, midY);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            ctx.strokeStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(0, lanes[0].y - lanes[0].width / 2);
            ctx.lineTo(canvas.width, lanes[0].y - lanes[0].width / 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, lanes[lanes.length - 1].y + lanes[lanes.length - 1].width / 2);
            ctx.lineTo(canvas.width, lanes[lanes.length - 1].y + lanes[lanes.length - 1].width / 2);
            ctx.stroke();

            for (let i = objects.length - 1; i >= 0; i--) {
                if (!objects[i].update()) objects.splice(i, 1);
                else objects[i].draw(ctx);
            }

            ctx.save();
            ctx.translate(vehicle.x, vehicle.y);
            if (vehicle.isCrashed) {
                const progress = vehicle.crashFrame / 80;
                const flicker = Math.sin(vehicle.crashFrame * 0.3) > 0 ? 0.5 : 1;
                ctx.fillStyle = `rgba(255, ${Math.floor(100 * flicker)}, 0, ${1 - progress*0.5})`;
                const shrink = 1 - progress;
                ctx.fillRect(-vehicle.width/2*shrink, -vehicle.height/2*shrink, vehicle.width*shrink, vehicle.height*shrink);
            } else {
                ctx.fillStyle = vehicle.emergencyBraking ? '#ff0000' : '#00ff00';
                ctx.fillRect(-vehicle.width/2, -vehicle.height/2, vehicle.width, vehicle.height);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-vehicle.width/2, -vehicle.height/2, vehicle.width, vehicle.height);
                ctx.fillStyle = '#ffff99';
                ctx.fillRect(-vehicle.width/4, -vehicle.height/2, vehicle.width/8, 3);
                ctx.fillRect(vehicle.width/4, -vehicle.height/2, vehicle.width/8, 3);
            }
            ctx.restore();

            if (showSensors) {
                const len = 200;
                ctx.strokeStyle = 'rgba(0,255,0,0.5)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(vehicle.x, vehicle.y); ctx.lineTo(vehicle.x + len, vehicle.y); ctx.stroke();
                ctx.fillStyle = 'rgba(0,255,0,0.3)'; ctx.beginPath(); ctx.arc(vehicle.x + len, vehicle.y, 6, 0, Math.PI*2); ctx.fill();

                ctx.strokeStyle = 'rgba(0,255,100,0.5)';
                ctx.beginPath(); ctx.moveTo(vehicle.x, vehicle.y); ctx.lineTo(vehicle.x + len*0.9, vehicle.y - len*0.5); ctx.stroke();
                ctx.fillStyle = 'rgba(0,255,100,0.3)'; ctx.beginPath(); ctx.arc(vehicle.x + len*0.9, vehicle.y - len*0.5, 6, 0, Math.PI*2); ctx.fill();

                ctx.strokeStyle = 'rgba(0,200,255,0.5)';
                ctx.beginPath(); ctx.moveTo(vehicle.x, vehicle.y); ctx.lineTo(vehicle.x + len*0.9, vehicle.y + len*0.5); ctx.stroke();
                ctx.fillStyle = 'rgba(0,200,255,0.3)'; ctx.beginPath(); ctx.arc(vehicle.x + len*0.9, vehicle.y + len*0.5, 6, 0, Math.PI*2); ctx.fill();
            }

            if (isRunning) {
                frameCount++;
                if (frameCount - lastAutoSpawnFrame > autoSpawnInterval) {
                    const type = autoSpawnTypes[Math.floor(Math.random()*autoSpawnTypes.length)];
                    const lane = Math.floor(Math.random()*lanes.length);
                    objects.push(new DrivingObject(type, -50, lanes[lane].y, 4, lane));
                    lastAutoSpawnFrame = frameCount;
                }

                detectObjects();
                checkPersonVehicleCollisions();
                checkVehicleCollisions();
                updateVehicleControl();
                updateActionLog();
                updateStats();
            }

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (deleteMode) {
                for (let i = objects.length - 1; i >= 0; i--) {
                    const obj = objects[i];
                    if (obj.getDistance(x, y) < Math.max(obj.width, obj.height)) {
                        objects.splice(i, 1);
                        break;
                    }
                }
                return;
            }

            if (!spawnMode) return;

            if (['car', 'bus', 'truck'].includes(spawnMode)) {
                let closestLane = 0;
                let minDist = Math.abs(y - lanes[0].y);
                for (let i = 1; i < lanes.length; i++) {
                    const d = Math.abs(y - lanes[i].y);
                    if (d < minDist) { minDist = d; closestLane = i; }
                }
                objects.push(new DrivingObject(spawnMode, x, lanes[closestLane].y, 4, closestLane));
            } else if (spawnMode === 'custom_person') {
                const name = document.getElementById('personName').value.trim() || null;
                const color = document.getElementById('personColor').value;
                const p = new DrivingObject('person', x, y);
                if (name) p.name = name;
                p.color = color;
                objects.push(p);
            } else {
                objects.push(new DrivingObject(spawnMode, x, y, spawnMode === 'person' ? 2 : 0));
            }

            spawnMode = null;
            document.getElementById('spawnHint').style.display = 'none';
            document.querySelectorAll('button.spawn-mode').forEach(b => b.classList.remove('spawn-mode'));
        });

        function makeSpawnButton(id, type) {
            document.getElementById(id).addEventListener('click', function() {
                if (spawnMode === type) {
                    spawnMode = null;
                    this.classList.remove('spawn-mode');
                    document.getElementById('spawnHint').style.display = 'none';
                } else {
                    spawnMode = type;
                    document.querySelectorAll('button.spawn-mode').forEach(b=>b.classList.remove('spawn-mode'));
                    this.classList.add('spawn-mode');
                    document.getElementById('spawnHint').style.display = 'block';
                }
                deleteMode = false;
                document.getElementById('deleteMode').classList.remove('delete-mode');
            });
        }

        makeSpawnButton('spawnCar', 'car');
        makeSpawnButton('spawnBus', 'bus');
        makeSpawnButton('spawnTruck', 'truck');
        makeSpawnButton('spawnStopSign', 'stop sign');
        makeSpawnButton('spawnTrafficLight', 'traffic light');
        makeSpawnButton('spawnYield', 'yield');
        makeSpawnButton('spawnBuilding', 'building');
        makeSpawnButton('spawnTree', 'tree');
        makeSpawnButton('spawnPole', 'pole');

        document.getElementById('spawnPerson').addEventListener('click', function() {
            const active = spawnMode === 'custom_person';
            spawnMode = active ? null : 'custom_person';
            this.classList.toggle('spawn-mode', !active);
            document.getElementById('personCustomizer').style.display = active ? 'none' : 'flex';
            document.getElementById('spawnHint').style.display = active ? 'none' : 'block';
            if (!active) document.getElementById('spawnHint').textContent = 'Click on canvas to place custom person';
        });

        document.getElementById('spawnTrafficJam').addEventListener('click', () => {
            const lane = Math.floor(Math.random() * lanes.length);
            for (let i = 0; i < 5; i++) {
                const type = autoSpawnTypes[Math.floor(Math.random()*autoSpawnTypes.length)];
                objects.push(new DrivingObject(type, 150 + i*80, lanes[lane].y, 0.5, lane));
            }
        });

        document.getElementById('spawnGroupPeople').addEventListener('click', () => {
            for (let i = 0; i < 6; i++) {
                const x = 200 + Math.random()*(canvas.width-400);
                const y = 100 + Math.random()*(canvas.height-200);
                objects.push(new DrivingObject('person', x, y));
            }
        });

        document.getElementById('startStop').addEventListener('click', function() {
            isRunning = !isRunning;
            this.textContent = isRunning ? 'Stop' : 'Start';
        });

        document.getElementById('deleteMode').addEventListener('click', function() {
            deleteMode = !deleteMode;
            this.classList.toggle('delete-mode');
            spawnMode = null;
            document.querySelectorAll('button.spawn-mode').forEach(b=>b.classList.remove('spawn-mode'));
            document.getElementById('spawnHint').style.display = deleteMode ? 'block' : 'none';
            document.getElementById('spawnHint').textContent = deleteMode ? 'Click on any object to delete it' : '';
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            objects.length = 0;
            document.getElementById('actionLog').innerHTML = '<li class="info">Scene cleared</li>';
        });

        document.getElementById('toggleSensors').addEventListener('click', function() {
            showSensors = !showSensors;
            this.textContent = showSensors ? 'Sensors ON' : 'Sensors OFF';
            this.classList.toggle('active', showSensors);
        });

        document.getElementById('restartBtn').addEventListener('click', restartVehicle);

        ['lightRed','lightYellow','lightGreen'].forEach(id => {
            document.getElementById(id).addEventListener('click', () => {
                selectedTrafficLightColor = id === 'lightRed' ? '#ff0000' : id === 'lightYellow' ? '#ffaa00' : '#00ff00';
                document.querySelectorAll('.light-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(id).classList.add('active');
            });
        });

        document.getElementById('lightGreen').classList.add('active');

        animate();
    </script>
</body>
</html>
